\renewcommand{\myincludegraphics}[2]{\includegraphics[#2]{chap6/#1}}

\chapter{高度なプログラミング\label{prog2}}

%----------------------------------------------------------------------------
%\newpage
\section{クロス開発}

第\ref{prog1}章では，
ハンドアセンブルにより機械語のプログラムを作成しました．
プログラムをニーモニックから機械語に手作業で変換する際，
ミスが多発しました．
このようにミスが多発するので，
実は，ハンドアセンブルによるプログラムの開発は，
ほとんど行われません．

この授業の中では，
原理をよく理解してもらうために，
あえて面倒なハンドアセンブルをたくさんしてもらいました．
そろそろ，機械語の原理はよく分かってきたので，
楽にプログラミングする方法を教えます．
%その代わりに，これまでより，
%たくさんのプログラムを作成してもらいます．

プログラムを作成することを「プログラムを開発する」と言います．
楽に「開発する」ために使用するコンピュータやプログラムのことを，
「開発環境」と言います．
「開発環境」には，「セルフ開発環境」と「クロス開発環境」があります．

「セルフ開発環境」は，
%UNIXやmacOS，またはWindows
パソコンでJava言語やC言語でプログラムを作成し実行するような，
プログラムを開発するコンピュータと実行するコンピュータが同じ場合に
用いる「開発環境」です．

「クロス開発環境」は，
TeCのような小さなコンピュータのプログラム開発によく用いられます．
他のコンピュータ上でプログラムを作成し，
出来上がったプログラムを目的のコンピュータに転送して実行するような
「開発環境」です．
「クロス開発」環境を用いたプログラムの開発は，「クロス開発」と呼ばれます．

%----------------------------------------------------------------------------
\subsection{TeCクロス開発環境}
「TeCクロス開発環境」は，
アセンブラとダウンロードプログラムからなります．
「TeCクロス開発環境」の入手とパソコンへのインストール方法は，
\url{https://github.com/tctsigemura/Tasm}を参照してください．
以下では，UNIXまたはmacOSに「TeCクロス開発環境」が
インストールされていることを前提に説明します．
また，「TeCクロス開発環境」の詳細は，
「付録\ref{cross} TeCクロス開発環境」を参照してください．

%----------------------------------------------------------------------------
\subsection{アセンブラ}

ニーモニックから機械語に変換する作業を，
これまでは，手作業（ハンドアセンブル）により行ってきました．
このような単純で機械的な作業はコンピュータが得意なものです．
この作業を行うプログラムを「アセンブラ」と言います．
アセンブラは，ニーモニックで記述したプログラムを機械語に変換します．

\subsubsection{TeC用アセンブラの使用方法}

TeC用のアセンブラは，
UNIXやmacOS，またはWindows上で動作する「クロスアセンブラ」です．
クロスアセンブラを使用したプログラムの作成手順は次の通りです．

\begin{enumerate}
\item テキストエディタを用いてソースプログラムを入力します．
ソースプログラムを格納するファイルの拡張子は``{\tt .t7}''でなければなりません．
例えば，\figref{chap6:source}のソースプログラムを
``{\tt xxx.t7}''ファイルに書込みます．

\begin{figure}[bt]
{\small\begin{lstlisting}[xleftmargin=5mm]
; 入力例
   ld g0,a
   st g0,b
   halt
a  dc 10
b  ds 1
\end{lstlisting}}
\caption{ソースプログラムの例}
\label{fig:chap6:source}
\end{figure}

\figref{chap6:source}の内容を説明します．
1行目は注釈の例です．`{\tt ;}'から行末までが注釈になります．
ラベルのない行（2，3，4行）は，一つ以上の空白を書いた後，命令を書きます．
ラベルのある行（5，6）は，行の1文字目からラベルを書きます．
なお，例では命令のインデントが揃っていますが，
揃える必要はありません．

\item アセンブラを実行します．
アセンブラのコマンド名は，{\tt tasm7}です．
実行例を\figref{chap6:tasm7}に示します．

\begin{figure}[bt]
{\small\begin{lstlisting}[numbers=none]
$ tasm7 xxx.t7
アセンブル成功
結果は [xxx.lst] と [xxx.bin] に格納しました．

[xxx.lst]
ADR CODE     Label   Instruction

00           ; 入力例
00  10 05            LD     G0,A
02  20 06            ST     G0,B
04  FF               HALT
05  0A       A       DC     10
06  00       B       DS     1
$
\end{lstlisting}}
\caption{tasm7の実行例}
\label{fig:chap6:tasm7}
\end{figure}

入力にミスがなければ，
アセンブルリストと機械語プログラムが生成されます．

入力にミスがあった場合は，
\figref{chap6:error}のようにエラーメッセージが表示され，
エラーの場所と原因が分かるようになっています．

\begin{figure}[bt]
{\small\begin{lstlisting}[numbers=none]
$ tasm7 yyy.t7
＊＊＊ エラー[未知のニーモニック] ＊＊＊
エラー発生場所 : ファイル [yyy.t7] の 3行で
エラー行の内容 : [   SL G0,B]
エラートークン : [SL]
$
\end{lstlisting}}
\caption{エラーが発生するtasm7の実行例}
\label{fig:chap6:error}
\end{figure}
\end{enumerate}

\subsubsection{TeC用アセンブラの出力}

\begin{enumerate}
\item アセンブルリスト\\
画面と拡張子``{\tt .lst}''のファイルに，
アセンブルリストが出力されます．
アセンブルリストは，
入力したニーモニックと，
それから作られた機械語の対応を分かり易く表示したものです．
ハンドアセンブルで行っていた機械語作成の結果と
同じになっていることを確認してください．

\item 機械語プログラムファイル\\
拡張子``{\tt .bin}''のファイルに機械語が格納されます．
ファイルの内容は，
「\ref{appB:fileformat} 機械語プログラムファイル形式」で説明します．
\end{enumerate}

%----------------------------------------------------------------------------
\subsection{ダウンロード}

アセンブラを実行することにより，
拡張子``{\tt .bin}''のファイルに機械語が格納されました．
次に，この機械語をTeCの主記憶にダウンロードします．
ダウンロード方法は{\tt tsend7}コマンドを用いる方法\footnote{
全てのTeC7で使用できます．
tsend7を用いる方法は「TeC教科書 Ver. 4.0.5」
（\url{https://github.com/tctsigemura/TecTextBook/blob/v4.0.5/tec.pdf}）
に解説してあります
}と，{\tt twrite7}コマンドを用いる方法\footnote{
TeC7c以降の機種で使用できます．
}の二種類があります．
以下では{\tt twrite7}コマンドを用いる方法を説明します．

プログラムをダウンロードするには，
パソコンとTeCをUSBケーブルで接続し通信できる状態にした上で，
パソコンで{\tt twrite7}コマンドを実行します．
ケーブルの接続方法は「\ref{sio} TeCシリアル入出力」を参照してください．
ダウンロード手順は次の通りです．

\begin{enumerate}
\item パソコンで{\tt tasm7}を用いて{\tt .bin}ファイルを作成します．
\item パソコンで{\tt .bin}ファイルを指定して
  {\tt twrite7}コマンドを実行します．
  その様子を\figref{chap6:twrite7}に示します．
\item 自動的にコンソールパネルが操作され，
  {\tt .bin}ファイルのプログラムがTeCの主記憶装置（メモリ）に書き込まれます．
\item {\tt twrite7}はプログラムの先頭アドレスをPCに自動的にセットします．
\end{enumerate}

\begin{figure}[bt]
{\small\begin{lstlisting}[numbers=none]
$ twrite7 xxx.bin
[00][07][10][05][20][06][ff][0a][00]
$
\end{lstlisting}}
\caption{twrite7の実行例}
\label{fig:chap6:twrite7}
\end{figure}

以上の操作で，
手動でコンソールパネルから機械語を打ち込むこと無く，
機械語がTeCの記憶装置に書き込まれました．
主記憶装置に書き込まれたプログラムを実行したりデバッグしたりする方法は，
手動でコンソールパネルから機械語を打ち込んだ場合と同様です．

%----------------------------------------------------------------------------
\newpage
\subsubsection{問題}
\begin{enumerate}
\item 「\reidairef{5_5} ビットの回転」をクロス開発環境を用いてやり直しなさい．
\item 「\reidairef{5_3} 割算を計算する」をクロス開発環境を用いてやり直しなさい．
\item 「\reidairef{5_8} 文字列出力2」をクロス開発環境を用いてやり直しなさい．
\end{enumerate}

\subsubsection{注意}
同じシリアル通信機能を
「クロス開発環境」と「文字列出力プログラム」の両方で使用します．
プログラムのダウンロード時には，
パソコンのターミナルプログラムを終了する必要があります．

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{framed}{\parindent=1em
\subsection*{ニーモニック入力上の注意}

\begin{itemize}
\item TeCのアセンブラは，文字データ以外では，
アルファベット大文字と小文字を区別しません．
小文字で記述しても，アセンブルリストには大文字に変換されて表示されます．
\item `{\tt A}'〜`{\tt F}'の文字で始まる16進数は，
前に`{\tt 0}'を付加する必要があります．
アルファベットで始まる16進数は，ラベルと区別ができないためです．
（例 {\tt F1H} → {\tt 0F1H}）
\item 空白の表現には，スペースとタブのどちらも使用できます．
インデントを揃えるにはタブを使用すると便利です．
また，空白の文字数はいくつでも構いません．
読みやすいように，上手に空白を使用してください．
\item `{\tt ;}'をニーモニックの中に書くと，
次の文字から行末までが注釈（コメント）になります．
上手に注釈を入れて，読みやすいプログラムにしてください．
\item 文字や文字列の表記も，
これまで使用してきた`文字'や``文字列''の記述が使用できます．
実際に使用する記号は，「{\tt '}」
（パソコンの日本語キーボードでは，シフトを押しながら「7」）と，
「{\tt "}」（シフトを押しながら「2」）です．
本書の記述の中では，左と右のクォートに異なる記号を用いている
場合もありますが，実際には同じ記号です．
\end{itemize}
}\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\newpage
\section{スタック}

スタックは，
一時的にデータを保管するために使用できます．
例えば，レジスタの個数が足らなくなったとき
レジスタの値をスタックに一時退避しておき，
後でレジスタに復元することができます．

同じことを，
ST，LD命令と「名前を付けた領域」を用いて行うことも可能ですが，
スタックを利用すると「名前を付けた領域」を使用する必要がありません．
スタックもメモリ上の領域ですが，
名前を付けたりすることなしに，
プログラムのあちこちから同じ領域を繰り返し使用することができます．


%----------------------------------------------------------------------------
\subsection{仕組み}

スタックは，CPUのスタックポインタ（SPレジスタ）により管理されます．
\figref{chap6:stack}のように，
最初はSPがスタック領域の最後の番地を記憶しています．
スタックに値を保存するときは，
SPの値から1を引き新しいアドレスを決め，
そのアドレスに値を保存します．
値を保存する度にSPの値は減少していきます．

スタックから値を取り出すときは，
SPの示すアドレスの値を取り出し，
次にSPの値に1を加えます．
値を取り出す度にSPの値は増加していきます．

\myfigureN{tbp}{width=0.9\columnwidth}{stack1.pdf}
{スタックの仕組み}{chap6:stack}

このように，スタックを用いると，
保存したのとは逆の順番で値を取りだすようになります．
最後に入れたデータを最初に取り出すので，
スタックはLIFO（Last In First Out）方式のデータ構造です．

%----------------------------------------------------------------------------
\subsection{PUSH命令}

Pushは，「押す」と言う意味の英語です．
データをスタックに「押し込む」のに使用します．

\begin{description}
\item[意味：]レジスタの値をスタックに押し込む．

\item[ニーモニック：]{\tt PUSH  GR} \\
{\tt GR}で指定されたレジスタがスタックに押し込まれます．
{\tt GR}がSPを表す場合は，
SPの値がスタックに押し込まれます．

\item[命令フォーマット：]PUSH命令は，1バイト長の命令です．
XRフィールドは必ず$00_2$にします．

\oneByte{$1101_2$}{\GR~$00_2$}

\item[動作の詳細：]PUSH命令は，まず，スタックポインタ（SP）の値を1減らします．
次に，SPの値をアドレスとみなし，
主記憶のSP番地に指定されたレジスタの値を書き込みます．

\item[フローチャート：]
次のように描くことにします．

\begin{center}
\myincludegraphics{push.pdf}{scale=0.8}
\end{center}

\end{description}

%----------------------------------------------------------------------------
\subsection{POP命令}

Popは，「飛び出る」と言う意味の英語です．
データをスタックから取り出すのに使用します．

\begin{description}
\item[意味：]スタックのデータをレジスタに取り出す．

\item[ニーモニック：]{\tt POP  GR} \\
{\tt GR}で指定されたレジスタにスタックからデータが取り出されます．
{\tt GR}がSPを表す場合は，
スタックからデータが取り出され，SPに格納されます．

\item[命令フォーマット：]POP命令は，1バイト長の命令です．
XRフィールドは必ず$10_2$にします．

\oneByte{$1101_2$}{\GR~$10_2$}

\item[動作の詳細：]POP命令は，まず，
主記憶のSP番地からデータを取り出し，
指定されたレジスタに格納します．
次に，SPの値を1増やします．

\item[フローチャート：]
次のように描くことにします．

\begin{center}
\myincludegraphics{pop.pdf}{scale=0.8}
\end{center}
\end{description}

\subsubsection{PUSH/POP命令の応用例(1)}
\figref{chap6:regsave}のように，
PUSH命令とPOP命令を組み合わせて，
レジスタの値を一時的に保管することができます．
まず，SPの値を初期化します．
DCH番地に初期化する理由は，
「\figref{appC:insttbl} TeC7命令表」のメモリマップを参照して考えてください．
スタックはLIFOなので，
PUSH（保存）した順序と逆の順序でPOP（復元）する必要があります．

\begin{figure}[bt]
{\tt\small\begin{center}
\begin{tabular}{|l|l l l|}
\hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & \\
\hline
    & LD   & SP,\#0DCH&            \\
    & ...  &          &            \\
    & \multicolumn{3}{|l|}{G0，G1を使用する処理1} \\
    & ...  &          &            \\
    & PUSH & G0       & ; G0を保存 \\
    & PUSH & G1       & ; G1を保存 \\
    & ...  &        & \\
    & \multicolumn{3}{|l|}{G0，G1を使用する処理2} \\
    & ...  &          &            \\
    & POP  & G1       & ; G1を復元 \\
    & POP  & G0       & ; G0を復元 \\
    & ...  &        & \\
    & \multicolumn{3}{|l|}{処理1の続き} \\
    & ...  &          &            \\
\hline
\end{tabular}
\end{center}}
\caption{スタックにレジスタの値を一時退避する例}
\label{fig:chap6:regsave}
\end{figure}

\subsubsection{PUSH/POP命令の応用例(2)}
\figref{chap6:regcopy}のように，
PUSH命令とPOP命令を組み合わせて，
レジスタの値を別のレジスタにコピーすることができます．
TeCにはレジスタ間のデータ転送命令がないので，
このテクニックは役に立ちます．
次の例ではG0の値をG1にコピーします．

\begin{figure}[bt]
{\tt\small\begin{center}
\begin{tabular}{|l|l l l|}
\hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & \\
\hline
    & LD   & SP,\#0DCH&            \\
    & ...  &          &            \\
    & PUSH & G0       & ; G0を保存 \\
    & POP  & G1       & ; G1に復元 \\
    & ...  &        & \\
\hline
\end{tabular}
\end{center}}
\caption{スタックを用いたレジスタ間のコピーの例}
\label{fig:chap6:regcopy}
\end{figure}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
スタックを利用してG0とG1の値を交換する方法を考えなさい．
\vfill

%----------------------------------------------------------------------------
\newpage
\section{サブルーチン}

プログラムの中に同じ処理が何度も出てくることがあります．
また，一つのまとまった機能を実現している部分があり，
他の部分と独立させた方がプログラムの見通しが良くなる場合があります．

例えば，「\ref{sio} TeCシリアル入出力（SIO）」の例題プログラムの多くで，
1文字入力や1文字出力を行うプログラムの部分がありました．
このような部分はサブルーチン（副プログラム）としてまとめることにより，
繰り返し呼び出して使用したり，
他の部分から独立させて見やすいプログラムにすることができます．
ここでは，サブルーチンを作る方法を学びます．

%----------------------------------------------------------------------------
\subsection{仕組み}

サブルーチンは，他のプログラムから呼び出されて実行されます．
サブルーチンの実行が終わったら，
呼び出したプログラムに戻り続きを実行します．
サブルーチンを呼び出すための CALL 機械語命令と，
サブルーチンの最後から呼び出し元に戻るための RET 機械語命令を新たに導入します．

\figref{chap6:sub}のプログラムは，
1文字出力機能をサブルーチンとして独立させ，
メインルーチン（主プログラム）から2回呼び出します．
プログラムは先頭から実行が開始され
CALL 命令で PUTCH サブルーチンへジャンプします．
PUTCH サブルーチンを最後まで実行すると
RET 命令でメインルーチンに戻り，
CALL 命令の次の命令から実行を再開します．

\begin{figure}[bt]
{\tt\small\begin{center}
\begin{tabular}{|l|l l l|}
\hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & \\\hline
START & LD   & SP,\#0DCH  &                      \\
      & LD   & G0,\#'A'   &                      \\
      & CALL & PUTCH      & ; サブルーチン呼出し \\
      & LD   & G0,\#'B'   &                      \\
      & CALL & PUTCH      & ; サブルーチン呼出し \\
      & HALT &            &                      \\
      &      &            &                      \\
PUTCH & IN   & G1,03H     & ; １文字出力         \\
      & AND  & G1,\#80H   & ;サブルーチン        \\
      & JZ   & PUTCH      &                      \\
      & OUT  & G0,02H     &                      \\
      & RET  &            &                      \\\hline
\end{tabular}
\end{center}}
\caption{サブルーチンの例}
\label{fig:chap6:sub}
\end{figure}

%----------------------------------------------------------------------------
\subsection{CALL命令}

Callは，「呼び出す」と言う意味の英語です．
サブルーチンを呼び出すために使用します．
CALL命令はJMP命令に似ていますが，
サブルーチンから戻る準備をしてからジャンプしなければなりません．
CALL 命令は，自身の次の命令のアドレスをスタックに保存（PUSH）してから，
サブルーチンにジャンプします．

\begin{description}
\item[意味：]サブルーチンを呼び出す．

\item[フラグ：]変化しません．

\item[ニーモニック：]{\tt CALL  EA} \\
{\tt EA}番地のサブルーチンを呼び出します．
{\tt EA}にインデクスドモードは使用できますが,
イミディエイトモードは使用できません．

\item[命令フォーマット：] CALL命令は2バイトの長さを持ちます．
各フィールドの意味は JMP 命令と同様です．
GRフィールドは必ず$00_2$にします．

\twoByte{$1011_2$}{$00_2$~\XR}{\A}

\item[動作の詳細：] CALL命令は，まず，
PCの値（CALL命令実行時には既に次の命令のアドレスになっている）を，
スタックに保存（PUSH）します．
次に，サブルーチンにジャンプします．

\item[フローチャート：]
次のように描きます．
箱の中には，呼び出すサブルーチンの名前を書きます．

\begin{center}
\myincludegraphics{call.pdf}{scale=0.9}
\end{center}

\item[使用上の注意：]
CALL命令が使用するスタックはPUSH命令やPOP命令が使用するのと同じものです．
CALL命令を使用する前にSPを初期化する必要があります．

\end{description}

%----------------------------------------------------------------------------
\newpage
\subsection{RET（Return）命令}

Returnは，「戻る」と言う意味の英語です．
RETはReturnの綴を縮めたものです．
サブルーチンから戻るために使用します．

\begin{description}
\item[意味：] サブルーチンから戻る．

\item[フラグ：] 変化しません．

\item[ニーモニック：] {\tt RET}

\item[命令フォーマット：] RET命令は，1バイト長の命令です．

\oneByte{$1110_2$}{$11_2$~$00_2$}

\item[動作の詳細：]
スタックから値を一つ取り出しPCにセットします．
スタックにはCALL命令が保存したPCの値が保存されているので，
プログラムの実行は，
サブルーチンを呼び出したCALL命令の次の命令に移ります．

\item[フローチャート：]
次のフローチャートの，最後の角を取った四角がRET命令に対応します．
フローチャートは，サブルーチン全体を示しています．

\begin{center}
\myincludegraphics{ret.pdf}{scale=0.8}
\end{center}

\item[使用上の注意：]
RET命令はPOP命令と同様な方法でスタックから値を取り出します．
サブルーチンの中でPUSH命令やPOP命令を使用した場合は，
スタックの状態がサブルーチンの実行開始時と同じになるようにしてから，
RET命令を実行しなければなりません．
サブルーチンの中で，
PUSH命令の実行回数とPOP命令の実行回数が同じになるようにして下さい．

\end{description}

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{reidai}{`A'〜`Z'の文字を表示（改良版1）}{6_1}
\begin{description}
\item[問題：] SIOへ`A'〜`Z'の文字を連続して出力するプログラムを，
前ページの1文字出力サブルーチン（PUTCH）を使用して作りなさい．

\item[考え方：]
基本的な考え方は「\reidairef{5_9} `A'〜`Z'の文字を表示」と同じです．
1文字出力サブルーチンはG0レジスタにセットされた値をSIOへ出力します．
メインルーチンは，G0レジスタに`A'〜`Z'の文字の文字コードをセットして，
サブルーチンを呼び出します．

\item[フローチャート：]
サブルーチンの呼び出しとサブルーチンは次のように描きます．

\begin{center}
\myincludegraphics{flowI.pdf}{scale=0.75}
\end{center}

\item[プログラム：]
CALL，RET命令がスタックを使用するので，
まず，SPの初期化をします．
G0レジスタを文字コードの格納に，
G1レジスタを「Tビット」のチェックに用います．

{\tt\footnotesize\begin{center}
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD  & EQU  & 02H             \\
03 &       & SIOS  & EQU  & 03H             \\
%00 &       &       &      &                 \\
00 & 1F DC & START & LD   & SP,\#0DCH       \\
02 & 13 41 &       & LD   & G0,\#'A'        \\
04 & B0 0F & LOOP  & CALL & PUTCH           \\
06 & 53 5A &       & CMP  & G0,\#'Z'        \\
08 & A4 0E &       & JZ   & OWARI           \\
0A & 33 01 &       & ADD  & G0,\#1          \\
0C & A0 04 &       & JMP  & LOOP            \\
0E & FF    & OWARI & HALT &                 \\
%0F &       &       &      &                 \\
0F & C4 03 & PUTCH & IN   & G1,SIOS         \\
11 & 67 80 &       & AND  & G1,\#80H        \\
13 & A4 0F &       & JZ   & PUTCH           \\
15 & C3 02 &       & OUT  & G0,SIOD         \\
17 & EC    &       & RET  &                 \\
\hline
\end{tabular}
%\\TeC6ではCALL命令の機械語がBCになります．
\end{center}}
\end{description}
\end{reidai}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{reidai}{`A'〜`Z'の文字を表示（改良版2）}{6_2}
\begin{description}
\item[問題：] SIOへ`A'〜`Z'の文字を連続して出力した後，
SIOへ改行コードを出力するプログラムを作りなさい．

\item[考え方：]
%「\reidairef{6_1} `A'〜`Z'の文字を表示（改良版1）」では，
%サブルーチンを使用したメリットが明確になりませんでした．
%同じ，
サブルーチン（PUTCH）を
メインルーチンの複数の箇所から呼び出します．
%出すプログラムを作成します．

\item[フローチャート：]
改行するために，CR，LFを出力します．

\begin{center}
\myincludegraphics{flowJ.pdf}{scale=0.75}
\end{center}

\item[プログラム：]
PUTCH ルーチンは，
「\reidairef{6_1} `A'〜`Z'の文字を表示（改良版1）」と同様なので省略しました．

{\tt\footnotesize\begin{center}
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD  & EQU  & 02H             \\
03 &       & SIOS  & EQU  & 03H             \\
%00 &       &       &      &                 \\
00 & 1F DC & START & LD   & SP,\#0DCH       \\
02 & 13 41 &       & LD   & G0,\#'A'        \\
04 & B0 17 & LOOP  & CALL & PUTCH           \\
06 & 53 5A &       & CMP  & G0,\#'Z'        \\
08 & A4 0E &       & JZ   & OWARI           \\
0A & 33 01 &       & ADD  & G0,\#1          \\
0C & A0 04 &       & JMP  & LOOP            \\
0E & 13 0D & OWARI & LD   & G0,\#13         \\
10 & B0 17 &       & CALL & PUTCH           \\
12 & 13 0A &       & LD   & G0,\#10         \\
14 & B0 17 &       & CALL & PUTCH           \\
16 & FF    &       & HALT &                 \\
%17 &       &       &      &                 \\
17 & C4 03 & PUTCH & ...   &                \\
\hline
\end{tabular}
%\\TeC6ではCALL命令の機械語がBCになります．
\end{center}}
\end{description}
\end{reidai}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{reidai}{文字列出力（改良版1）}{6_3}
\begin{description}
\item[問題：] SIOへローマ字で自分の名前を出力するプログラムを作りなさい．

\item[考え方：]
「\reidairef{5_7} 文字列出力1」をサブルーチンを使用して作りなおします．

\item[フローチャート：]
G1レジスタが PUTCH サブルーチンで破壊される
（Tビットのチェックで使用します．）ので，
メインルーチン側で G1 レジスタをスタックに保存しています．

\begin{center}
\myincludegraphics{flowK.pdf}{scale=0.75}
\end{center}

\item[プログラム：]PUTCHルーチンは省略します．

{\tt\footnotesize\begin{center}
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD  & EQU  & 02H             \\
03 &       & SIOS  & EQU  & 03H             \\
%00 &       &       &      &                 \\
00 & 1F DC & START & LD   & SP,\#0DCH       \\
02 & 17 00 &       & LD   & G1,\#0          \\
04 & 1B 09 &       & LD   & G2,\#9          \\
06 & 11 1E & LOOP  & LD   & G0,DATA,G1      \\
08 & D4    &       & PUSH & G1              \\
09 & B0 15 &       & CALL & PUTCH           \\
0B & D6    &       & POP  & G1              \\
0C & 37 01 &       & ADD  & G1,\#1          \\
0E & 4B 01 &       & SUB  & G2,\#1          \\
10 & A4 14 &       & JZ   & END             \\
12 & A0 06 &       & JMP  & LOOP            \\
%14 &       &       &      &                 \\
14 & FF    & END   & HALT &                 \\
15 &       &       &      &                 \\
15 & C4 03 & PUTCH & ...  &                 \\
1E &       &       &      &                 \\
1E & 53 48 & DATA  & DC   & "SHIGEMURA"     \\
20 & ...   &       &      &                 \\
\hline
\end{tabular}
%\\TeC6ではCALL命令の機械語がBCになります．
\end{center}}
\end{description}
\end{reidai}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{reidai}{文字列出力（改良版2）}{6_4}
\begin{description}
\item[問題：] SIOへローマ字で自分の名前を出力するプログラムを作りなさい．

\item[考え方：]
「\reidairef{5_7} 文字列出力1」をサブルーチンを使用して作りなおします．

\item[フローチャート：]
PUTCH サブルーチンがG1レジスタを破壊しないようにしました．
「\reidairef{6_3} 文字列出力（改良版1）」より完成度の高いPUTCH サブルーチンです．

\begin{center}
\myincludegraphics{flowL.pdf}{scale=0.75}
\end{center}

\item[プログラム：]PUTCH ルーチンも掲載します．

{\tt\footnotesize\begin{center}
\begin{tabular}{|c|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD  & EQU  & 02H             \\
03 &       & SIOS  & EQU  & 03H             \\
%00 &       &       &      &                 \\
00 & 1F DC & START & LD   & SP,\#0DCH       \\
02 & 17 00 &       & LD   & G1,\#0          \\
04 & 1B 09 &       & LD   & G2,\#9          \\
06 & 11 1E & LOOP  & LD   & G0,DATA,G1      \\
08 & B0 13 &       & CALL & PUTCH           \\
0A & 37 01 &       & ADD  & G1,\#1          \\
0C & 4B 01 &       & SUB  & G2,\#1          \\
0E & A4 12 &       & JZ   & END             \\
10 & A0 06 &       & JMP  & LOOP            \\
12 & FF    & END   & HALT &                 \\
%13 &       &       &      &                 \\
13 & D4    & PUTCH & PUSH & G1              \\
14 & C4 03 & WAIT  & IN   & G1,SIOS         \\
16 & 67 80 &       & AND  & G1,\#80H        \\
18 & A4 14 &       & JZ   & WAIT            \\
1A & C3 02 &       & OUT  & G0,SIOD         \\
1C & D6    &       & POP  & G1              \\
1D & EC    &       & RET  &                 \\
%1E &       &       &      &                 \\
1E & 53 48 49 & DATA  & DC   & "SHIGEMURA"     \\
%21 & ...   &       &      &                 \\
21 & 47 45 4D &       &      &                 \\
24 & 55 52 41 &       &      &                 \\
\hline
\end{tabular}
%\\TeC6ではCALL命令の機械語がBCになります．
\end{center}}
\end{description}
\end{reidai}
\end{figure}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item SIOから1文字を入力するサブルーチン（GETCH）を作成しなさい．
GETCH は，
入力した文字の文字コードを G0 に格納して戻るものとします．
\item 前出の1文字出力サブルーチン（PUTCH）とGETCH を利用し，
「\reidairef{5_10} echo プログラム」を作りなおしなさい．
\item 「\reidairef{5_3} 割算を計算する」を参考に，
割算サブルーチン DIV を作成しなさい．
DIV は，G0 に割られる数，G2 に割る数をセットして呼び出され，
G1 に商，G0 に余りを格納して戻ります．
\item 「\reidairef{5_6} シフトを用いた高速乗算」を参考に，
G0の数値の10倍を計算しG0に求めるサブルーチン MUL10 を作成しなさい．
\end{enumerate}
\vfill

%----------------------------------------------------------------------------
\newpage
\section{時間の計測}

コンピュータで，正確な時間を計る必要がある場合があります．
%例えば，TeC を使って3分間のタイマを作ることを想像してください．
時間を計測するための専用の回路を使用できる場合もありますが，
TeCのような小規模マイコンは専用の回路を持っていないことがあります．
そこで，プログラムだけで時間を計測する工夫が必要になります．

\subsection{マシンステート}

プログラムだけで一定の時間が経過するのを待つには，
各命令の実行に必要な時間を調べて，
ちょうど目的の時間が必要な命令の組合せを実行させます．

命令表にステート数と書かれた欄があります．
ここの数値が命令の実行に要する時間を表します．
例えば，NO命令はステート数3の命令ですので，
{\bf 3マシンステート}の時間が必要になります．

TeCの場合，{\bf 1マシンステート}は，
回路の動く基準になるクロック信号の1周期分になります．
TeCのクロック信号は，2.4576MHzですので，
{\bf 1マシンステート}は，
$1/(2.4576\times10^6) = 0.4069\times10^{-6} = 0.4069 \mu s$です．
例えば，NO命令はステート数が3なので，
実行に$0.4069 \mu s \times 3 = 1.2207 \mu s$の時間がかかります．
他の命令も，同様に実行時間が決まります．

\subsection{1ms タイマ（マシンステートの応用）}
\label{ms}

マシンステートの合計を調節して，
実行にちょうど 1ms の時間がかかるサブルーチンを作ります．
クロックの周波数から，
1秒が$2.4576 \times 10^{6}$マシンステートになりますので，
$1ms$は，$(2.4576 \times 10^{6}) \times (1 \times 10^{-3}) = 2,457.6$
マシンステートになります．

実行に，$2,458$マシンステートを要するサブルーチンを作ります．
ステート数が多いので繰り返しを使用しないと，うまくいきそうにありません．
繰り返しを利用したプログラムは，
\figref{chap6:1ms}のようになります．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l|l|} \hline
ラベル & \multicolumn{2}{|c|}{ニーモニック}& ステート \\
\hline
MS1   & PUSH & G0            & 6   \\
      & LD   & G0,\#n        & 5   \\
MATU  & SUB  & G0,\#1        & 5   \\
      & JZ   & KAERU         & 4/5 \\
      & JMP  & MATU          & 5   \\
KAERU & POP  & G0            & 6   \\
      & RET  &               & 6   \\
\hline
\end{tabular}
\end{center}}
\caption{1msタイマーサブルーチン}
\label{fig:chap6:1ms}
\end{figure}

このプログラムの実行に要するステート数は，
繰り返し回数を $n$ とすると，
$ 6 + 5 + ( 5 + 4 + 5 ) \times (n - 1) + 5 + 5 + 6 + 6$
となります．
ステート数が$2,458$になるような$n$を計算すると，
$n$は$174$になります（3ステート不足）．
\figref{chap6:1ms}のプログラムで$n$を$174$にしたものが，
実行に約$1ms$かかるサブルーチンになります．

%----------------------------------------------------------------------------
\subsection{0.2 秒タイマ（入れ子サブルーチンの利用）}
\label{ms200}

%もう少し長いタイマを作って
%実行に時間がかかっていることを実感しましょう．

$1ms$タイマサブルーチンを利用すると，
もっと長い時間のタイマサブルーチンを簡単に作ることができます．
0.2秒タイマルーチン（\figref{chap6:200ms}の MS200 サブルーチン）は，
$1ms$タイマサブルーチンを 200 回呼び出すように作ります．
「サブルーチンの中から別のサブルーチンを呼び出すこと」を
「サブルーチンの入れ子」と言います．
ここでは「サブルーチンの入れ子」を利用しています．

\figref{chap6:200ms}のプログラム全体では，
MS200 サブルーチンを 5 回呼び出して，
実行に約1秒かかるプログラムの例になっています．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l|} \hline
ラベル & \multicolumn{2}{|c|}{ニーモニック}        \\
\hline
      & \multicolumn{2}{|l|}{; メインルーチン}     \\
START & LD   & SP,\#0DCH                           \\
      & CALL & MS200                               \\
      & CALL & MS200                               \\
      & CALL & MS200                               \\
      & CALL & MS200                               \\
      & CALL & MS200                               \\
      & HALT &                                     \\
      & \multicolumn{2}{|l|}{; 200ms サブルーチン} \\
MS200 & PUSH & G0                                  \\
      & LD   & G0,\#200                            \\
L1    & CALL & MS1                                 \\
      & SUB  & G0,\#1                              \\
      & JZ   & L2                                  \\
      & JMP  & L1                                  \\
L2    & POP  & G0                                  \\
      & RET  &                                     \\
      & \multicolumn{2}{|l|}{; 1ms サブルーチン}   \\
MS1   & PUSH & G0                                  \\
      & LD   & G0,\#174                            \\
MATU  & SUB  & G0,\#1                              \\
      & JZ   & KAERU                               \\
      & JMP  & MATU                                \\
KAERU & POP  & G0                                  \\
      & RET  &                                     \\
\hline
\end{tabular}
\end{center}}
\caption{0.2秒タイマーサブルーチン}
\label{fig:chap6:200ms}
\end{figure}

%----------------------------------------------------------------------------
\subsection{1 秒タイマ（多重ループの利用）}

約$1ms$のタイマを200回呼び出すサブルーチンを5回呼び出す方法では，
誤差がたまって，正確な1秒タイマではなくなっている可能性があります．
正確な1秒タイマを，1から作りなおします．

1秒タイマは，$2,457,600$ マシンステートのプログラムになります．
$1ms$タイマでは，繰り返し1回が14ステートでした．
同じステート数だとすると，
$2,447,600 / 14 = 174,828回$ ループを繰り返す必要があります．
カウンタに使用したレジスタは8ビットですから，256回のカウントが限界です．
そこで，\figref{chap6:loop2}に示すフローチャートのように
繰り返しを更に繰り返す（2重ループ）プログラムを作成する必要があります．

\myfigureN{tbp}{scale=0.8}{flowB.pdf}{２重ループ}{chap6:loop2}

ところが，256回を256回繰り返しても，
まだ，繰り返し回数の$174,828回$に足りません．
そこで，
実際には「「「繰り返し」の繰り返し」の繰り返し」（3重ループ）を作ります．
\figref{chap6:loop3}にプログラムを示します．
繰り返し回数は，
プログラムを書いてプログラム各部のステート数が定まった後で，
試行錯誤で決めました．
%最後のNO命令2個により，
%ちょうど$2,457,600$ステートのプログラムになっています．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|c|l|l|l l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{3}{|c|}{ニーモニック} \\
\hline
00 & 13 6C & START & LD    & G0,\#108       & ; 5    \\
02 & 17 CC & L1    & LD    & G1,\#204       & ; 5    \\
04 & 1B 07 & L2    & LD    & G2,\#7         & ; 5    \\
06 & 4B 01 & L3    & SUB   & G2,\#1         & ; 5    \\
08 & A4 0C &       & JZ    & L4             & ; 4/5  \\
0A & A0 06 &       & JMP   & L3             & ; 5    \\
0C & 47 01 & L4    & SUB   & G1,\#1         & ; 5    \\
0E & A4 12 &       & JZ    & L5             & ; 4/5  \\
10 & A0 04 &       & JMP   & L2             & ; 5    \\
12 & 43 01 & L5    & SUB   & G0,\#1         & ; 5    \\
14 & A4 18 &       & JZ    & L6             & ; 4/5  \\
16 & A0 02 &       & JMP   & L1             & ; 5    \\
%18 &       &       &       &                &        \\
18 & 00    & L6    & NO    &                & ; 3    \\
19 & 00    &       & NO    &                & ; 3    \\
1A & FF    &       & HALT  &                & ; 3    \\
\hline
\end{tabular}
\end{center}}
\caption{３重ループを用いた1秒タイマー}
\label{fig:chap6:loop3}
\end{figure}

%----------------------------------------------------------------------------
\newpage
\subsubsection{問題}
\begin{enumerate}
\item 0.2秒タイマサブルーチンを使用した，
1秒タイマプログラムを入力して実行しなさい．
\item 0.2秒タイマサブルーチンを利用して，
ブザーを1秒間隔で 0.2秒間鳴らすプログラムを作りなさい．
このプログラムは STOP を押すまで繰り返し実行するものとします．
\item 多重ループを利用した1秒タイマプログラムを入力して実行しなさい．
\item 2重ループの練習として，
SIOに `A' 10文字の行を，5行出力するプログラムを作りなさい．
\item 入れ子サブルーチンの練習として，
SIOに `A' 10文字の行を，5行出力するプログラムを作りなさい．
（1行出力サブルーチンを5回呼び出す．
1行出力サブルーチンは，1文字出力サブルーチンを10回呼び出す．）
\item 最初の3分間は1秒毎にブザーを鳴らし，
3分経過したらブザーを鳴らしっぱなしするプログラム（3分タイマ）
を作りなさい．
\end{enumerate}

%\begin{center}
%{\bf `A' を10文字，5行出力した例}\\
%{\small\tt\begin{tabular}{| l l l l l l l l l l |}
%\hline
%  &   &   &   &   &   &   &   &   &   \\
%A & A & A & A & A & A & A & A & A & A \\
%A & A & A & A & A & A & A & A & A & A \\
%A & A & A & A & A & A & A & A & A & A \\
%A & A & A & A & A & A & A & A & A & A \\
%A & A & A & A & A & A & A & A & A & A \\
%  &   &   &   &   &   &   &   &   &   \\
%\hline
%\end{tabular}}
%\end{center}

%----------------------------------------------------------------------------
\newpage
\section{数値の入出力}

これまでにSIOを使用した文字の入出力を勉強しました．
ここでは数値の入出力を扱います．

\subsection{2進数の出力}

データを2進数として表現したものを人間に読める形式で SIO に出力します．
ビットの 0 は文字の `0' に，
ビットの 1 は文字の `1' に変換します．
\figref{chap6:bin}に1バイトのデータを表示するプログラムを示します．

このプログラムは，
DATA 番地の内容を上位ビットから順に `0'，`1'の文字に変換し，
SIO へ出力します．
8ビット分の出力が終わると，
CR（0DH），LF（0AH） を出力して画面を改行します．
文字の出力には前出の PUTCH サブルーチンを使用します．
%このプログラムを実行すると，
パソコンの画面に，DATA 番地のデータ CAH を2進数で表した，
``11001010'' が表示されます．
%実際に実行してみてください．

\begin{figure}
{\small\tt\begin{center}
\begin{tabular}{|c|l|l|l l |} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       & SIOD   & EQU    & 2                 \\
03 &       & SIOS   & EQU    & 3                 \\
%00 &       &        &        &                   \\
00 & 1F DC & START  & LD     & SP,\#0DCH         \\
02 & 14 29 &        & LD     & G1,DATA           \\
04 & 1B 08 &        & LD     & G2,\#8            \\
06 & 13 31 & L1     & LD     & G0,\#'1'          \\
08 & 95    &        & SHLL   & G1                \\
09 & A8 0D &        & JC     & L2                \\
0B & 13 30 &        & LD     & G0,\#'0'          \\
0D & B0 1E & L2     & CALL   & PUTCH             \\
0F & 4B 01 &        & SUB    & G2,\#1            \\
11 & A4 15 &        & JZ     & L3                \\
13 & A0 06 &        & JMP    & L1                \\
%15 &       &        &        &                   \\
15 & 13 0D & L3     & LD     & G0,\#0DH          \\
17 & B0 1E &        & CALL   & PUTCH             \\
19 & 13 0A &        & LD     & G0,\#0AH          \\
1B & B0 1E &        & CALL   & PUTCH             \\
1D & FF    &        & HALT   &                   \\
%1E &       &        &        &                   \\
1E & D4    & PUTCH  & PUSH   & G1                \\
1F & C4 03 & PL1    & IN     & G1,SIOS           \\
21 & 67 80 &        & AND    & G1,\#80H          \\
23 & A4 1F &        & JZ     & PL1               \\
25 & C3 02 &        & OUT    & G0,SIOD           \\
27 & D6    &        & POP    & G1                \\
28 & EC    &        & RET    &                   \\
29 &       &        &        &                   \\
29 & CA    & DATA   & DC     & 0CAH              \\
\hline
\end{tabular}
\end{center}}
\caption{2進数を表示するプログラム}
\label{fig:chap6:bin}
\end{figure}

%----------------------------------------------------------------------------
\subsection{16進数の出力}

DATA 番地のデータを16進数で SIO に出力するプログラムを
\figref{chap6:hex}に示します．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|c|l|l|l l |} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &               & SIOD   & EQU    & 2                   \\
03 &               & SIOS   & EQU    & 3                   \\
%00 &               &        &        &                     \\                
00 & 1F DC         & START  & LD     & SP,\#0DCH           \\
02 &               &        & \multicolumn{2}{l|}{; 上位桁の出力} \\
02 & 14 38         &        & LD     & G1,DATA             \\
04 & 97            &        & SHRL   & G1                  \\
05 & 97            &        & SHRL   & G1                  \\
06 & 97            &        & SHRL   & G1                  \\
07 & 97            &        & SHRL   & G1                  \\
08 & 11 28         &        & LD     & G0,HSTR,G1          \\
0A & B0 1D         &        & CALL   & PUTCH               \\
0C &               &        & \multicolumn{2}{l|}{; 下位桁の出力} \\
0C & 14 38         &        & LD     & G1,DATA             \\
0E & 67 0F         &        & AND    & G1,\#0FH            \\
10 & 11 28         &        & LD     & G0,HSTR,G1          \\
12 & B0 1D         &        & CALL   & PUTCH               \\
14 &               &        & \multicolumn{2}{l|}{; 改行の出力} \\
14 & 13 0D         &        & LD     & G0,\#0DH            \\
16 & B0 1D         &        & CALL   & PUTCH               \\
18 & 13 0A         &        & LD     & G0,\#0AH            \\
1A & B0 1D         &        & CALL   & PUTCH               \\
1C & FF            &        & HALT   &                     \\
1D &               &        & \multicolumn{2}{l|}{; 1文字出力} \\
1D & D4            & PUTCH  & PUSH   & G1                  \\
1E & C4 03         & WAIT   & IN     & G1,SIOS             \\
20 & 67 80         &        & AND    & G1,\#80H            \\
22 & A4 1E         &        & JZ     & WAIT                \\
24 & C3 02         &        & OUT    & G0,SIOD             \\
26 & D6            &        & POP    & G1                  \\
27 & EC            &        & RET    &                     \\
28 &               &        & \multicolumn{2}{l|}{; 16進数字} \\
28 & 30 31 32 33   & HSTR   & DC     & "01234567"          \\
2C & 34 35 36 37   &        &        &                     \\
30 & 38 39 41 42   &        & DC     & "89ABCDEF"          \\
34 & 43 44 45 46   &        &        &                      \\
38 &               &        & \multicolumn{2}{l|}{; 出力するデータ} \\
38 & CA            & DATA   & DC     & 0CAH                \\
\hline
\end{tabular}
\end{center}}
\caption{16進数を表示するプログラム}
\label{fig:chap6:hex}
\end{figure}

まず，データの上位4ビットを取り出し，
その値から`0'〜`F'の1文字を選択し SIO へ出力します．
次に，下位4ビットを用いて同様の出力をします．
最後に，
CR（0DH），LF（0AH） を出力し画面を改行します．
%このプログラムを実行すると，
パソコンの画面に ``CA'' が表示されます．

%----------------------------------------------------------------------------
\subsection{10進数の出力}

DATA 番地のデータを 10進数で SIO に出力するプログラムを考えましょう．
扱うデータは 8ビットの符号無し2進数（0 〜 255）とします．
10進数で表示するには， 
10進数の一桁一桁に分解した後，
一桁毎に対応する数字に変換して出力します．

\subsubsection{各桁への分解}
次のような手順で数値を一桁一桁に分解します．
下にデータが123だった場合の計算例を示しますので，
計算例と比較しながら手順を確認して下さい．

\begin{enumerate}
\item データを10で割って商と余りを求めます．
この時，余りが最下位桁（1位桁）の値です．

\item 商を更に10で割って新しい商と余りを求めます．
新しい余りが下から2桁目（10位桁）の値です．

\item 新しい商は下から3桁目（100位桁）の値になります．
\end{enumerate}

\begin{center}
\begin{tabular}{l l}
{\bf 計算例} & \\
$10 \underline{) ~~123 } $ & \\
$10 \underline{) ~~~12 } {\cdots 3}$ & （余り3が1位桁の値）\\
$~~  ~~~~~~~1 {\cdots 2}$            & （余り2が10位桁の値） \\
                                     & （商1が100位桁の値）
\end{tabular}
\end{center}

以上の手順をプログラムにするためには，割算機能が必要です．
%しかし，TeCは割算命令を持っていません．
ここでは，「\reidairef{5_3} 割算を計算する」を
サブルーチン化してDIVと言う名前で準備済みと仮定します．
\figref{chap6:bunkai}は
割算サブルーチン DIV を使用した桁への分解プログラム（部分）です．
各桁の値は，D1，D2，D3 の3バイトに格納されます．
後で，これらの値を上の桁から順に出力します．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント    \\
\hline
PUTDEC & LD   & SP,\#0DCH        & ; SP 初期化  \\
       & LD   & G0,DATA          & ; 割られる数     \\
       & LD   & G2,\#10          & ; 割る数         \\
       & CALL & DIV              & ; 割算           \\
       & ST   & G0,D1            & ; 余り（1位桁）  \\
       & PUSH & G1               & ; 商を           \\
       & POP  & G0               & ; 割られる数に   \\
       & CALL & DIV              & ; 割算           \\
       & ST   & G0,D2            & ; 余り（10位桁） \\
       & ST   & G1,D3            & ; 商（100位桁）  \\
\hline
\end{tabular}
\end{center}}
\caption{各桁に分する部分}
\label{fig:chap6:bunkai}
\end{figure}

\subsubsection{各桁の出力}
桁への分解ができたら，
分解した各桁を上の桁から順に数字に変換して SIO へ出力します．
数字の文字コードが `0' 〜 `9' まで連続していることを利用すると，
数値から数字への変換は簡単にできます．

\begin{center}
$数字 = 数値 + $`0'の文字コード
\end{center}

変換結果を PUTCH サブルーチンを利用して SIO へ出力します．
\figref{chap6:hitoketa}は
100位桁の値を数字に変換し出力するプログラム（部分）です．
10位桁，1位桁も同様に出力すれば3桁の数値を表示できます．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント    \\
\hline
       & LD   & G0,D3            & ; 100位桁の数値      \\
       & ADD  & G0,\#'0'         & ; 文字コードへ変換  \\
       & CALL & PUTCH            & ; SIOへ出力         \\
\hline
\end{tabular}
\end{center}}
\caption{一桁目を数字に変換し出力する部分}
\label{fig:chap6:hitoketa}
\end{figure}

%----------------------------------------------------------------------------
\subsection{10進数の入力}

10進数の出力ができるようになったので，
今度は入力を考えましょう．
10進数の出力と逆の手順で行います．
まず，一桁毎に入力し数字を数値に変換します．
次に，各桁の値を合成して一つの数値にします．

\subsubsection{各桁の入力}

入力は符号無し8bit 2進数で表現できる 0 〜 255 の数値とします．
今回はプログラムの作りやすさを優先して，
3桁の数字しか入力されない前提で考えます．
100未満の数値を入力するときは，
``012''のように上の1桁に`0'を入力します．
10未満の数値を入力するときは，
``001''のように上の2桁に`0'を入力します．

1文字入力し入力した文字の文字コードから`0'の文字コードを引きます．
これで，数字に対応した数値が求まります．
入力された各桁の値は，メモリ上の領域に保存しておきます．

\begin{center}
$数値 = 数字 - $`0'の文字コード
\end{center}

ここまでの手順をプログラムにすると\figref{chap6:henkan}のようになります．
プログラム中で1文字入力（GETCH）毎に1文字出力（PUTCH）しているのは，
入力した文字がパソコンの画面に表示されるようにするためです．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント    \\
\hline
GETDEC & LD   & SP,\#0DCH        & ; SP 初期化           \\
       & CALL & GETCH            & ; 1文字入力           \\
       & CALL & PUTCH            & ; エコーバック        \\
       & SUB  & G0,\#'0'         & ; 文字コードから値に  \\
       & ST   & G0,D3            & ; 100位桁             \\
       & CALL & GETCH            & ; 1文字入力           \\
       & CALL & PUTCH            & ; エコーバック        \\
       & SUB  & G0,\#'0'         & ; 文字コードから値に  \\
       & ST   & G0,D2            & ; 10位桁              \\
       & CALL & GETCH            & ; 1文字入力           \\
       & CALL & PUTCH            & ; エコーバック        \\
       & SUB  & G0,\#'0'         & ; 文字コードから値に  \\
       & ST   & G0,D1            & ; 1位桁               \\
\hline
\end{tabular}
\end{center}}
\caption{3桁入力し数値に変換してメモリに保存する部分}
\label{fig:chap6:henkan}
\end{figure}

\subsubsection{各桁の値の合成}

下の式で目的の値を求めることができます．
2行目のように計算すれば
10倍を計算するサブルーチンを2回呼び出せば良いことになります．

\begin{eqnarray}
値 & = 100位桁 \times 100 + 10位桁 \times 10 + 1位桁 \nonumber\\
   & = ((100位桁 \times 10) + 10位桁) \times 10 + 1位桁 \nonumber
\end{eqnarray}

この計算をプログラムにすると\figref{chap6:gousei}のようになります．
ここで MUL10 は，G0 値の 10 倍を計算するサブルーチンです．
予め，「\reidairef{5_6} シフトを用いた高速乗算」を参考に，
MUL10 を作成しておく必要があります．

\begin{figure}[bpt]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント    \\
\hline
       & LD   & G0,D3         & ; 100位桁    \\
       & CALL & MUL10         & ; × 10      \\
       & ADD  & G0,D2         & ; 10位桁     \\
       & CALL & MUL10         & ; × 10      \\
       & ADD  & G0,D1         & ; 1位桁      \\
       & ST   & G0,DATA       & ; 結果を保存 \\
\hline
\end{tabular}
\end{center}}
\caption{各桁の値を合成する部分}
\label{fig:chap6:gousei}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{framed}{\parindent=1em
\subsection*{掛算の回数}
一般に，
掛算や割算は時間のかかる計算です．
TeCのような掛算命令や割算命令を持たない小さなコンピュータにとっては
特に時間がかかります．
掛算や割算の回数は少なくするべきです．
「各桁の値の合成」で掛算の回数が少なくるなるように式を変形したのは，
そのような意味からです．
}\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\newpage
\subsubsection{問題}
\begin{enumerate}
\item SIO から入力した文字の文字コードを16進数で出力するプログラムを
作成しなさい．
（1文字入力サブルーチン（GETCH），
16進数出力サブルーチン（PUTHEX）を作成し，
これらを用いてプログラムを完成しなさい．）
\item 本文中のプログラムを参考に，
DATA番地のデータを10進数で出力するプログラムを完成しなさい．
\item 10進数の出力プログラムを，
出力する数値の桁数に合わせて先行する余分な`0'が出力されないよう改良しなさい．
\item 10進数の出力プログラムを，
D1，D2，D3 領域の代わりにスタックを使用するように改造しなさい．
\item 本文中のプログラムを参考に，
10進数を入力しDATA番地に格納するプログラムを作成しなさい．
\item 10進数を入力するプログラムを，
数字以外が入力されるまで入力を受け付けるように改造しなさい．
（3桁固定でなく，10[Enter]や1[Enter]で入力できるプログラムにする．）
\item 10進数を入力し，
10加えた値を10進数で出力するプログラムを作成しなさい．
（10進数入力サブルーチン（GETDEC），
10進数出力サブルーチン（PUTDEC）を作成し，
これらを用いてプログラムを完成しなさい．）
\item 二つの10進数を入力し，
和を10進数で出力するプログラムを作成しなさい．
\item ゼロが入力されるまで10進数を入力し，
合計を10進数で出力するプログラムを作成しなさい．
\end{enumerate}

%----------------------------------------------------------------------------
\newpage
\section{符号付数の入出力}

「\ref{minus} 負数の表現」で学んだように，
負の数は2の補数表現を用いて表現します．
%TeC も，負の数を2の補数表現を用いて表現します．
TeC は 8bit 符号付 2 進数を扱うので
--128 〜 +127 の数値を扱うことができます．

データが符号付であるか符号無しであるかは，
そのデータをプログラムがどのように扱うかで決まります．
特にデータの外部表現を左右する入出力ルーチンは，
%符号付の場合とそうでない場合で，
処理内容がはっきり区別されます．

\subsection{符号付10進数の出力}
\figref{chap6:out10}にG0に格納された符号付 2 進数の値を
SIO へ出力するサブルーチンのフローチャートを示します．
なお，G0 に格納した1文字を出力する PUTCH サブルーチン，
G0 に格納した値を10進数として出力する PUTDEC サブルーチンが別に必要です．

まず，G0 の値と 0 を比較し，G0 の値が正か負かを判断します．
負の場合は，`--'を出力した後，G0 の値の符号を反転します．
符号の反転は，
「\ref{hanten} 2の補数から元の数を求める手順」で学習したように，
{\bf 「ビット反転した後，1を加える」}ことで実行できます．
ビットの反転には XOR 命令を使用します．
最後に，PUTDECサブルーチンを用いて G0 の値を 10 進数で出力します．

\myfigureN{btp}{scale=0.8}{flowM.pdf}{符号付き10進出力}{chap6:out10}

\subsection{符号付10進数の入力}

次のような形式の10進数を入力します．

\begin{quote}
正の数 :  空白 数字 数字 数字 \\
負の数 :  `--' 数字 数字 数字
\end{quote}

\figref{chap6:in10}に符号付数値を入力するサブルーチンの
フローチャートを示します．
なお，
SIO から1文字を入力し G0 に格納するサブルーチン GETCH，
SIO から10進数を入力し G0 に格納するサブルーチン GETDEC が，
予め準備してあるものとします．

まず，符号を入力しスタックに退避します．
続いて 10 進数を G0 に入力します．
退避しておいた符号を G1 に取り出し，
文字 `--' と比較します．
同じなら，G0 の符号を反転します．

\myfigureN{btp}{scale=0.8}{flowN.pdf}{符号付き10進入力}{chap6:in10}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item 符号付の10進数出力サブルーチン（PUTSDEC）を作成しなさい．
\item 符号付の10進数入力サブルーチン（GETSDEC）を作成しなさい．
\item ゼロが入力されるまで符号付の10進数を入力し，
合計を符号付10進数で出力するプログラムを作成しなさい．
\end{enumerate}
\vfill

%----------------------------------------------------------------------------
\newpage
\section{アドレスデータ}

番地をデータとして扱えると便利なことがあります．
番地（＝アドレス）のデータなので，
ここではアドレスデータと呼びます．
C言語を勉強したことのある人は，
ポインタのことだ言えばピンとくると思います．
アドレスデータを使用すると便利な例としては，
サブルーチンにデータの置き場所を教える場合が考えられます．

\subsection{TeCのアドレスデータ}

TeCでは，
インデクスドモードのアドレッシングを用いて，
レジスタで指定された特定アドレスのデータをアクセスすることが可能です．
例えば，
12H番地にあるデータをG0レジスタにロードするプログラムは，
次のようになります．

{\tt\small\begin{center}
\begin{tabular}{l l}
LD & G1,\#12H       \\
LD & G0,0,G1 \\
\end{tabular}
\end{center}}

G1インデクスドモードでは，
データのアドレスを 「第2バイト + G1」 で求めます．
このプログラムの場合，
第2バイトが0ですから，
G1 の値がそのままデータのアドレスになります．
つまり，
G1に格納されたアドレスデータを用いて，
そのアドレスをアクセスします．

\subsection{文字列出力サブルーチン}
アドレスデータの使用例として，
文字列出力サブルーチンを作ってみましょう．
サブルーチンには出力すべき文字列を渡す必要があります．
ここでは文字列を
%「\reidairef{5_8} 文字列出力2」で用いたのと同じ，
「\figref{chap6:str} 文字列データの表現例」に示すような
文字コード 0 で終わるバイト列として表現することにします．
（この文字列表現方式は，C言語と同じです．）

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l|l|l l|} \hline
番地 & \multicolumn{1}{|c|}{機械語}
     & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
1E & 53 48 49 47 & DATA  & DC   & "SHIGEMURA",0   \\
22 & 45 4D 55 52 &       &      &                 \\
26 & 41 00       &       &      &                 \\
\hline
\end{tabular}
\end{center}}
\caption{文字列データの表現例}
\label{fig:chap6:str}
\end{figure}

サブルーチンにデータを渡す方法として，
これまではレジスタを使用してきました．
例えば1文字出力サブルーチン（PUTCH）は，
出力したい文字の文字コードをG0に格納して呼び出されるようになっていました．
文字列の場合はデータの量が多いので
レジスタにデータ全体を格納してサブルーチンに渡すことができません．
そこで，
文字列データの置いてあるアドレスを渡すことにします．

\figref{chap6:outstr}のプログラムは，
文字列出力サブルーチン（PUTSTR）が
出力する文字列のアドレスを受け取るようにした例です．
G1に文字列のアドレスをセットしてPUTSTRを呼び出します．
なお，プログラム中「{\tt \#STR1}」のような記述は
{\tt STR1}ラベルの値を意味します．
どのような機械語へ変換されているか確認してください．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l|l|l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
\hline
02 &       &  SIOD   & EQU    & 02H             \\
03 &       &  SIOS   & EQU    & 03H             \\
00 &       &         &        &                 \\
00 & 1F DC & START   & LD     & SP,\#0DCH       \\
02 & 17 2F &         & LD     & G1,\#STR1       \\
04 & B0 13 &         & CALL   & PUTSTR          \\
06 & 17 41 &         & LD     & G1,\#CRLF       \\
08 & B0 13 &         & CALL   & PUTSTR          \\
0A & 17 39 &         & LD     & G1,\#STR2       \\
0C & B0 13 &         & CALL   & PUTSTR          \\
0E & 17 41 &         & LD     & G1,\#CRLF       \\
10 & B0 13 &         & CALL   & PUTSTR          \\
12 & FF    &         & HALT   &                 \\
13 &       &         &        &                 \\
13 &       &         & \multicolumn{2}{|l|}{; 文字列出力ルーチン} \\
13 & D0    &  PUTSTR & PUSH   & G0              \\
14 & D4    &         & PUSH   & G1              \\
15 & 11 00 &  LOOP   & LD     & G0,0,G1         \\
17 & 53 00 &         & CMP    & G0,\#0          \\
19 & A4 21 &         & JZ     & RETURN          \\
1B & B0 24 &         & CALL   & PUTCH           \\
1D & 37 01 &         & ADD    & G1,\#1          \\
1F & A0 15 &         & JMP    & LOOP            \\
21 & D6    &  RETURN & POP    & G1              \\
22 & D2    &         & POP    & G0              \\
23 & EC    &         & RET    &                 \\
24 &       &         &        &                 \\
24 &       &         & \multicolumn{2}{|l|}{; 1文字出力ルーチン} \\
24 & D4    &  PUTCH  & PUSH   & G1              \\
25 & C4 03 &  WAIT   & IN     & G1,SIOS         \\
27 & 67 80 &         & AND    & G1,\#80H        \\
29 & A4 25 &         & JZ     & WAIT            \\
2B & C3 02 &         & OUT    & G0,SIOD         \\
2D & D6    &         & POP    & G1              \\
2E & EC    &         & RET    &                 \\
2F &       &         &        &                 \\
2F & 53 48 &  STR1   & DC     & "SHIGEMURA",0   \\
31 & 49 47 &         &        &                 \\
33 & 45 4D &         &        &                 \\
35 & 55 52 &         &        &                 \\
37 & 41 00 &         &        &                 \\
%39 &       &         &        &                 \\
39 & 54 45 &  STR2   & DC     & "TETSUJI",0     \\
3B & 54 53 &         &        &                 \\
3D & 55 4A &         &        &                 \\
3F & 49 00 &         &        &                 \\
%41 &       &         &        &                 \\
41 & 0D 0A &  CRLF   & DC     & 0DH,0AH,0       \\
43 & 00    &         &        &                 \\
\hline
\end{tabular}
%\\TeC6ではCALL命令の機械語がBCになります．
\end{center}}
\caption{文字列出力サブルーチン}
\label{fig:chap6:outstr}
\end{figure}

%----------------------------------------------------------------------------
\subsection{ジャンプテーブル}
\label{jmptbl}
これまで，データのアドレスばかり考えてきましたが，
プログラムのアドレスも同様に扱うことができます．
インデクスドモードのアドレッシングは，
ジャンプ命令やCALL命令でも使用できます．

このことを利用すると，
表に登録してあるいくつかのサブルーチンから一つを選んで実行するプログラムを
つくることができます．
サブルーチンを登録してある表のことを，
ここでは，ジャンプテーブルと呼びます．

\subsubsection{ジャンプ命令を表にする場合}
ジャンプ命令やCALL命令のインデクスドアドレッシングは
ジャンプ先アドレスをインデクスレジスタを用いて計算します．
例えば，次のJMP命令は$A+G2番地$にジャンプします．

{\small\tt\begin{center}
\begin{tabular}{l l}
JMP & A,G2   \\
\end{tabular}
\end{center}}

次のプログラムは，
G2の値を使用してTBL以下のどれか一つのJMP命令を選択し，
PRG0，PRG1，...のいずれかにジャンプする例です．
つまり，Java言語やC言語のswitch文に似た動きをします．
JMP命令は2バイトの命令なので，
SHLLを用いてG2の値を2倍にしています．

{\small\tt\begin{center}
\begin{tabular}{l l l}
    & LD    & G2,N   \\
    & SHLL  & G2     \\
    & JMP   & TBL,G2 \\
TBL & JMP   & PRG0   \\
    & JMP   & PRG1   \\
\multicolumn{3}{c}{...} \\
\end{tabular}
\end{center}}

CALL命令を用いてサブルーチンを呼び出すこともできます．
CALL命令の次の命令にサブルーチンから戻ってき来るので，
注意して下さい．

{\small\tt\begin{center}
\begin{tabular}{l l l}
    & LD    & G2,N   \\
    & SHLL  & G2     \\
    & CALL  & TBL,G2 \\
\multicolumn{3}{c}{サブルーチンから戻る場所} \\
\multicolumn{3}{c}{...} \\
TBL & JMP   & PRG0   \\
    & JMP   & PRG1   \\
\multicolumn{3}{c}{...} \\
\end{tabular}
\end{center}}

\subsubsection{アドレスを表にする場合}
ジャンプ命令を表にすると表の要素が2バイトになります．
アドレスだけを表にすると表の要素が1バイトで済み，
メモリの節約になります．

次のプログラムは，アドレスを表にした例です．
G1の値を使用し，
表からPRG0，PRG1，... のどれかのアドレスを選びG2にロードします．
次に，JMP命令でG2の内容が表す番地にジャンプします．

{\small\tt\begin{center}
\begin{tabular}{l l l}
    & LD    & G1,N      \\
    & LD    & G2,TBL,G1 \\
    & JMP   & 0,G2      \\
TBL & DC    & PRG0      \\
    & DC    & PRG1      \\
\multicolumn{3}{c}{...} \\
\end{tabular}
\end{center}}

次のプログラムは，
CALL命令を用いてサブルーチンを呼び出す例です．

{\small\tt\begin{center}
\begin{tabular}{l l l}
    & LD    & G1,N      \\
    & LD    & G2,TBL,G1 \\
    & CALL  & 0,G2      \\
\multicolumn{3}{c}{サブルーチンから戻る場所} \\
\multicolumn{3}{c}{...} \\
TBL & DC    & PRG0   \\
    & DC    & PRG1   \\
\multicolumn{3}{c}{...} \\
\end{tabular}
\end{center}}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item G1レジスタで指定された番地から始まる
G0レジスタで指定されたバイト数の領域を，
00Hで埋めつくすサブルーチンを作りなさい．
\item C言語のswitch文が，
TeCの機械語でどのように表現できるか考察しなさい．
\end{enumerate}
\vfill

%----------------------------------------------------------------------------
\newpage
\section{割込み（Interrupt）}
\label{chap6:interrupt}

ノイマン型のコンピュータはプログラムの命令を逐次実行しますので，
仕事を順番に処理するのが基本です．
しかし緊急の仕事が発生したとき等は，
処理中の仕事を後回しにして，
緊急の仕事を先に処理しなければならない場合があります．
割込みは，
そのような緊急の事象をコンピュータに伝えて，
優先される処理を割り込ませる仕組です．
英語では割込みのことを Interrupt と言います．

割込みは
CPUの外部で発生した事象をハードウェアによりCPUに伝えることにより発生します．
割込みにはいくつかの種類があり，
\figref{chap6:int}に示すように，
CPUには割込みの種類毎に入力が用意されます．

割込みが発生すると，
CPUは現在実行中のプログラムを中断し，
予め登録された割込み処理プログラム
（「割込み処理ルーチン」または「割込みハンドラ」と呼びます）
の実行を開始します．
割込み処理ルーチンは割込みの種類毎に登録することができます．

\myfigureN{btp}{scale=1.0}{intr.pdf}{割込み信号}{chap6:int}

%----------------------------------------------------------------------------
\subsection{TeCの割込み種類}

TeCの割込みの種類は4種類です．
\tabref{chap6:int}に一覧表を示します．
4種類の割込みには，
``INT0''，``INT1''，``INT2''，``INT3''という名前が付いています．
ベクタは割込み処理ルーチンを登録するメモリの番地です．
（主記憶のDCH〜DFH番地の範囲はベクタと呼ばれる特別な領域です．）
例えば``INT0''の割込み処理ルーチンが12H番地から始まる場合は，
メモリのDCH番地に，12Hを書き込みます．

\subsubsection{インターバルタイマ割込み}
``INT0''はインターバルタイマに接続されています．
インターバルタイマは指定された時間間隔で繰返し割込みを発生します．
指定できる間隔は1/75秒〜256/75秒の範囲です．

\subsubsection{SIO受信割込み}
``INT1''はSIOに接続されておりSIOが文字を受信する度に割込みが発生します．

\subsubsection{SIO送信割込み}
``INT2''もSIOに接続されており
SIOが次の文字を送信可能になる度に割込みが発生します．

\subsubsection{コンソール割込み}
``INT3''はコンソールパネルに接続されています．
プログラム実行中にユーザがコンソールパネルのWRITEスイッチを押すと
割込みが発生します．

\begin{mytable}{btp}{TeCの割込みの種類}{chap6:int}
{\small\begin{tabular}{c | l | c} \hline\hline
\multicolumn{1}{c |}{\bf 名前} &
\multicolumn{1}{c |}{\bf 意味} &
\multicolumn{1}{c}{\bf ベクタ} \\
\hline
INT0 & インターバルタイマ割込み & DCH   \\
INT1 & SIO受信割込み            & DDH   \\
INT2 & SIO送信割込み            & DEH   \\
INT3 & コンソール割込           & DFH   \\
\end{tabular}}
\end{mytable}

%----------------------------------------------------------------------------
\subsection{TeCの割込み動作}
TeCのCPUはプログラム実行中，
前の機械語命令を実行し終え，
次の機械語命令を実行開始する前に，
割込みが発生していないかチェックします．
割込みが発生していた場合は次のような動作をします．

\begin{enumerate}
\item PCをスタックに保存（PUSH）する．
\item 割込み許可フラグをリセットする．（割込み禁止にする）
\item 割込みの種類（INT0〜INT3）に対応するベクタから，
割込み処理ルーチンのアドレスを読む．
\item 割込み処理ルーチンのアドレスをPCにセットする．
\end{enumerate}

%----------------------------------------------------------------------------
\subsection{EI（Enable Interrupt）命令}
Enable は「可能にする」という意味の英語です．
EI命令は割込み許可フラグをセットし割り込みを「可能」にします．

CPUがリセットされたとき（初期状態）は割込み禁止状態です．
プログラムは，SPの初期化や割込みベクタの設定等が完了し，
割込みを受け付ける準備ができたときEI命令を用いて割込みを許可します．

割込みが許可状態かそうでないかは，
「割込み許可フラグ」の状態によって決まります．
EI命令は「割込み許可フラグ」をセットします．

\begin{description}
\item[意味：]割込みを許可する．（割込み許可フラグをセットする．）

\item[フラグ：]C，S，Zフラグは変化しません．
割込み許可フラグがセットされます．

\item[ニーモニック：] {\tt EI}

\item[命令フォーマット：]EI 命令は1バイト長の命令です．

\oneByte{$1110_2$}{$00_2$~$00_2$}

\item[フローチャート：]
次のように描きます．

\begin{center}
\myincludegraphics{ei.pdf}{scale=0.8}
\end{center}

\end{description}

%----------------------------------------------------------------------------
%\newpage
\subsection{DI（Disable Interrupt）命令}

Disable は，「できなくする」という意味の英語です．
DI命令は割込み許可フラグをリセットし割り込みを「できなく」します．
プログラムがEI命令を用いて割込みを許可したあと，
割込まれると都合が悪くなったとき使用します．

割り込みが発生し割り込み処理ルーチンの実行が始まった時は，
自動的に割り込み禁止状態になります．
それ以外で割り込み禁止にしたいとき使用する命令です．

\begin{description}
\item[意味：]割込みを禁止する．（割込み許可フラグをリセットする．）

\item[フラグ：]C，S，Zフラグは変化しません．
割込み許可フラグがリセットされます．

\item[ニーモニック：] {\tt DI}

\item[命令フォーマット：]DI 命令は1バイト長の命令です．

\oneByte{$1110_2$}{$00_2$~$11_2$}

\item[フローチャート：]
次のように描きます．

\begin{center}
\myincludegraphics{di.pdf}{scale=0.8}
\end{center}

\end{description}

%----------------------------------------------------------------------------
\subsection{RETI（Return from Interrupt）命令}

割込み処理ルーチンから通常のプログラムへ戻るための，
特別なRET命令です．
RETI命令を実行して割込み処理ルーチンが終了すると，
CPUは割込み許可状態になり
割込みが発生したとき実行中だったプログラムに戻ります．

\begin{description}
\item[意味：]割込み処理ルーチンから戻る．

\item[フラグ：]C，S，Zフラグは変化しません．
割込み許可フラグがセットされます．

\item[ニーモニック：] {\tt RETI}

\item[命令フォーマット：]RETI 命令は1バイト長の命令です．

\oneByte{$1110_2$}{$11_2$~$11_2$}

\item[動作の詳細：]スタックから値を一つ取り出しPCにセットし，
割込み許可フラグをセットします．

\item[フローチャート：]
次のフローチャートの最後の角を取った四角が RETI 命令に対応します．
フローチャートは割り込み処理ルーチン全体を示しています．

\begin{center}
\myincludegraphics{reti.pdf}{scale=0.8}
\end{center}

\end{description}

%----------------------------------------------------------------------------
\subsection{PUSHF（Push Flag）命令}

フラグをスタックに保存する命令です．
主に割込み処理ルーチンで使用します．
割込みは，いつ発生するか分かりません．
割込み処理ルーチンが終了したあと以前のプログラムに戻って処理を続行するには，
CPUの状態を完全に元通りに復元する必要があります．
CPUの状態とはレジスタ（PC，SPを含む）とフラグの値のことです．
レジスタの値は，PUSH命令でスタックに退避することができます．
フラグの値は，PUSHF命令でスタックに退避します．

\begin{description}
\item[意味：]フラグをスタックに退避する．

\item[フラグ：]フラグは変化しません．

\item[ニーモニック：] {\tt PUSHF}

\item[命令フォーマット：]PUSHF 命令は1バイト長の命令です．

\oneByte{$1101_2$}{$11_2$~$01_2$}

\item[動作の詳細：]スタックに退避されるデータは次のような1バイトです．
Eが割込み許可フラグです．

{\tt\small\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|} \hline
E & 0 & 0 & 0 & 0 & C & S & Z \\
\hline
\end{tabular}
\end{center}}

\item[フローチャート：]次のように描きます．

\begin{center}
\myincludegraphics{pushf.pdf}{scale=0.8}
\end{center}

\end{description}


%----------------------------------------------------------------------------
\subsection{POPF（Pop Flag）命令}

フラグをスタックから復元する命令です．
主に割込み処理ルーチンで使用します．
割込み処理ルーチンはPOPF命令を使用してフラグの値を復元してから，
RETI命令で以前のプログラムに戻ります．

\begin{description}
\item[意味：]フラグをスタックから復元します．

\item[フラグ：]フラグはスタックから取り出した値により変化します．

\item[ニーモニック：] {\tt POPF}

\item[命令フォーマット：]POPF 命令は1バイト長の命令です．

\oneByte{$1101_2$}{$11_2$~$11_2$}

\item[動作の詳細：]スタックから取り出すデータはPUSHF命令と同じ形式です．

\item[フローチャート：]次のように描きます．

\begin{center}
\myincludegraphics{popf.pdf}{scale=0.8}
\end{center}

\end{description}

%----------------------------------------------------------------------------
\newpage
\section{タイマ割込み}

一般に，
コンピュータには割込みを発生するタイマが内蔵されています．
時間を計ったり複数の仕事を切替えるきっかけとして，
タイマから発生する割込みを使用するからです．

パソコンでは複数のプログラムが同時に実行されているように見えますが，
これは 1/10 〜 1/100 秒程度の間隔で実行するプログラムを切替えることにより，
複数のプログラムを同時に実行しているように見せているのです．
このとき，プログラムを切替えるきっかけになるのはタイマからの割込みです．

%TeC7とTeC6でタイマ割込みのハードウェアが大きく異なります．
%そこで，以下ではTeC7の場合とTeC6の場合に分けて説明します．
%----------------------------------------------------------------------------
\subsection{インターバルタイマ割込み}

TeCにはプログラムから周期を設定できるインターバルタイマが一つ内蔵されています．
インターバルタイマは指定した時間間隔で繰返し割込みを発生します．
インターバルタイマには8ビットのタイマ・カウンタと
8ビットの周期レジスタが内蔵されています．

\subsubsection{I/Oポート}
インターバルタイマのI/Oポートは，4番地，5番地に配置されています
（「\tabref{chap5:iomap} I/Oマップ」参照）．

\begin{enumerate}
\item タイマ・カウンタ \\
4番地をIN命令で読むとタイマ・カウンタの現在値を読み出すことができます．
タイマ動作中，この値は1/75秒毎にカウントアップされます．
そして値が周期レジスタの値と一致したら0に戻ります．
その後，カウントアップが再開されます．

\begin{center}
\myincludegraphics{timer1.pdf}{scale=1.2}
\end{center}

\item 周期レジスタ \\
周期レジスタ値によって割込みの発生周期が決まります．
4番地にOUT命令で書き込んだ値が周期レジスタに書き込まれます．
書き込む値を$n$とすると周期は次の式で計算できます．

$周期=(n+1)/75 秒$

周期レジスタの初期値は1秒に相当する74です．
「周期」を変更するとタイマはカウントを停止します．
下記のコントロールを使用してスタートし直す必要があります．

\begin{center}
\myincludegraphics{timer2.pdf}{scale=1.2}
\end{center}

\item ステータス \\
5番地をIN命令で読むとタイマがスタートしてから一周期の時間が
経過したかどうかを割込みを用いることなく知ることができます．
一周期時間が経過すると$b_7$の値が``1''に変化します．
$b_7$は「ステータス」を一度読みだすと``0''にクリアされます．
その後一周期時間が経過する度に$b_7$の値が``1''に変化します．

\begin{center}
\myincludegraphics{timer3.pdf}{scale=1.2}
\end{center}

\item コントロール \\
タイマ割込みの（許可／不許可），
タイマカウンタのカウント（スタート／ストップ）の情報を
5番地にOUT命令で書き込みます．
$b_7$が割込みの許可ビット，
$b_0$がタイマカウンタのスタートビットです．
タイマカウントをスタートすると，
タイマカウンタの値が``00H''にリセットされてからカウントが始まります．

\begin{center}
\myincludegraphics{timer4.pdf}{scale=1.2}
\end{center}

\end{enumerate}

\subsection{プログラミング例}
\figref{chap6:timer}に
インターバルタイマを用いたプログラムの例を示します．
このプログラムは1秒間隔でブザーのON/OFFを繰り返します．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント      \\
\hline
BUZ   & EQU   & 00H               & ; ブザーポート   \\
TMRVCT& EQU   & 0DCH              & ; 割込みベクタ   \\
TMRCNT& EQU   & 4                 & ; カウンタ       \\
TMRCTR& EQU   & 5                 & ; コントロール   \\
START & \multicolumn{3}{|l|}{; メインプログラム}     \\
      & LD    & SP,\#0DCH         & ; SP初期化       \\
      & LD    & G0,\#TMRINT       & ; 割込ルーチンを \\
      & ST    & G0,TMRVCT         & ;   ベクタに登録 \\
      & LD    & G0,\#74           & ; タイマ初期化   \\
      & OUT   & G0,TMRCNT         & ;   周期=1秒,    \\
      & LD    & G0,\#81H          & ;   割込み許可,  \\
      & OUT   & G0,TMRCTR	  & ;   カウント開始 \\
      & EI    &                   & ; CPUの割込許可  \\
WAIT  & LD    & G0,FLG            & ; フラグを       \\
      & CMP   & G0,\#0            & ;   チェック     \\
      & JZ    & WAIT              & ; 0の間は待つ    \\
      & LD    & G0,VAL            & ; ブザーポートの \\
      & XOR   & G0,\#01H          & ;   値を反転して \\
      & ST    & G0,VAL            & ;   記録すると   \\
      & OUT   & G0,BUZ            & ;   同時に出力   \\
      & LD    & G0,\#0            & ; フラグをクリア \\
      & ST    & G0,FLG            & ; 次の割込みを   \\
      & JMP   & WAIT              & ;   待つ         \\
      &       &                   &                  \\
      & \multicolumn{3}{|l|}{; 共有変数}             \\
FLG   & DC    & 0                 & ; フラグ         \\
VAL   & DC    & 0                 & ; ブザーポートの \\
      &       &                   & ;   現在値ひかえ \\
      & \multicolumn{3}{|l|}{; 割込みルーチン}       \\
TMRINT& PUSHF &                   & ; コンテキストを \\
      & PUSH  & G0                & ;   保存する     \\
      & LD    & G0,\#1            & ; フラグに       \\
      & ST    & G0,FLG            & ;   1を書き込む  \\
      & POP   & G0                & ; コンテキストを \\
      & POPF  &                   & ;   復元し       \\
      & RETI  &                   & ; 割込み終了     \\
\hline
\end{tabular}
\end{center}}
\caption{タイマ割込みプログラムの例}
\label{fig:chap6:timer}
\end{figure}

\subsubsection{メインプログラム}
\begin{enumerate}
\item スタックポインタの値を初期化します．
割込みが発生するとCPUが自動的にPCをスタックに保存するので，
割込みが発生する前にスタックポインタの値を初期化する必要があります．

\item INT0の割込みベクタに割込みルーチンの番地を書き込みます．
DCH 番地が INT0 の割込みベクタですので，
この番地に割込み処理ルーチンの先頭番地を書き込みます．

\item インターバルタイマの初期化を行います．
1秒ごとの割込みが必要なので74を周期レジスタに書き込みます．
続けてコントロールに81Hを書き込むことで
割込み可能な状態でタイマがカウントを開始します．

\item EI命令を実行してCPUを割込み許可状態にします．
これで，割込みを受け付ける準備ができました．
ループを実行して割込みの発生を待ちます．
TeCはCPUが停止しているときは割込みを受け付けませんので，
プログラムを終了しないで割込みの発生を待つ必要があります．

\item 割込みが発生すると割込みルーチンにより
共有変数FLGの値が``1''に書き換えられます．
FLGの値が``1''になったらブザーのON/OFFを変更した後，
FLGの値を``0''に戻します．
\end{enumerate}

\subsubsection{割込みルーチン}
\begin{enumerate}
\item メインルーチンがインターバルタイマを起動したので，
1秒に一度，インターバルタイマ割込み（INT0）が発生します．

\item 割込みが発生するとCPUはPCの値をスタックに保存した後，
割込みベクタに書いてある番地にジャンプします．
メインプログラムが INT0 の割込みベクタに
割込みルーチンの先頭番地を書き込んでいるので，
%タイマ割込み（INT0）が発生すると，
割込みルーチンへジャンプします．

\item 割込みルーチンは，
メインプログラムを実行中のCPUの状態（コンテキスト）を保存します．
割込みルーチンが破壊するのはG0レジスタだけですが，
念のためフラグも保存しています．

\item 割込み処理の内容はFLG変数に``1''を書き込むことです．

\item 処理が終わったらCPUの状態（コンテキスト）を元に戻して
メインプログラムにRETI命令で戻ります．
\end{enumerate}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item 「タイマ割込みプログラムの例」の動作を確認しなさい．
\item ``{\tt LD G0,\#TMRINT}''は，どんな機械語に変換されたか確認しなさい．
\end{enumerate}
\vfill

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{reidai}{3分間タイマ}{6_5}
\begin{description}
\item[問題：] タイマ割込みを使用した3分間タイマを作りなさい．
タイマは，3分経過したらブザーを鳴らしっぱなしにするものとします．

\item[考え方：]
1秒間隔でタイマ割込みが発生するようにし割込みの回数で時間を計ります．
%割込みルーチンでカウンタの値をインクリメントし，
180回目の割込みが発生したらブザーを鳴らしたままプログラムを終了します．
ブザーはリセットボタンを押して止めます．

\item[プログラム：]
割込みルーチンは180をカウントしたらフラグ（FLAG）をセットします．
メインルーチンは，フラグがセットされたらブザーを ON にして，
プログラムを終了します．
%なお，プログラムはTeC7用ですが，TeC6で実行することも可能です．

{\footnotesize\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント \\
\hline
TMRVCT & EQU    & 0DCH              &                 \\
TMRCNT & EQU    & 4                 & ; カウンタ      \\
TMRCTR & EQU    & 5                 & ; コントロール  \\
       & \multicolumn{3}{|l|}{; メインプログラム}     \\
START  & LD     & SP,\#0DCH         & ; SP初期化      \\
       & LD     & G0,\#0            & ; フラグと      \\
       & ST     & G0,FLAG           & ; カウンタ      \\
       & ST     & G0,CNT            & ; リセット      \\
       & LD     & G0,\#TMRINT       &                 \\
       & ST     & G0,TMRVCT         & ; ベクタ設定    \\
       & LD     & G0,\#74           & ; タイマ初期化  \\
       & OUT    & G0,TMRCNT         & ;   周期=1秒    \\
       & LD     & G0,\#81H          & ;   割込み許可  \\
       & OUT    & G0,TMRCTR	    & ;   カウント開始\\
       & EI     &                   & ; 割込み許可    \\
L1     & LD     & G0,FLAG           & ; フラグが0     \\
       & CMP    & G0,\#0            & ; の間          \\
       & JZ     & L1                & ; 繰り返す      \\
       & LD     & G0,\#01H          &                 \\
       & OUT    & G0,00H            & ; ブザーON      \\
       & HALT   &                   & ; 終了          \\
       & \multicolumn{3}{|l|}{; 割込み処理ルーチン}   \\
TMRINT & PUSHF  &                   & ; コンテキス    \\
       & PUSH   & G0                & ; スト保存      \\
       & LD     & G0,CNT            & ; 回数のカウ    \\
       & ADD    & G0,\#1            & ; ント          \\
       & ST     & G0,CNT            &                 \\
       & CMP    & G0,\#180          & ; 3分経過       \\
       & JZ     & TINT1             &                 \\
       & JMP    & TINT2             &                 \\
TINT1  & ST     & G0,FLAG           & ; フラグON      \\
TINT2  & POP    & G0                & ; コンテキ      \\
       & POPF   &                   & ; スト復元      \\
       & RETI   &                   &                 \\
       & \multicolumn{3}{|l|}{; 作業領域}             \\
FLAG   & DS     & 1                 & ; フラグ        \\
CNT    & DS     & 1                 & ; カウンタ      \\
\hline
\end{tabular}
\end{center}}
\end{description}
\end{reidai}
\end{figure}

%----------------------------------------------------------------------------
\newpage
\section{コンソール割込み}

コンソールパネルの操作でINT3割込みを発生することができます．
コンソール割込みを許可する手順は次の通りです．

\begin{enumerate}
\item スタックポインタを初期化する．

\item INT3割込みベクタにコンソール割込み処理ルーチンの番地を書き込む．

\item コンソール割込み（INT3）許可ビットをONにする．
割込み許可ビットはI/O 6番地の $b_0$ です
%（「\tabref{chap5:iomap} I/Oマップ」参照）．

\begin{center}
\myincludegraphics{console.pdf}{scale=1.2}
\end{center}

\item EI命令でCPUの割込みを許可する．
\end{enumerate}

以上の準備をした上で
プログラム実行中にコンソールパネルのWRITEボタンを押すと割込が発生します．

\subsubsection{コンソール割込みの応用例}

\figref{chap6:cons}コンソール割込みを応用したプログラム例を示します．
プログラムはコンソール割込みとタイマ割込みの両方を使用しています．
コンソールパネルの WRITE ボタンが押されるたびに0.3秒間ブザーを鳴らします．
以下の手順で機能が実現されています．

\begin{enumerate}
\item 初期化 \\
メインプログラムはスタックポインタとタイマ等のハードウェアを初期化し，
CPUを割込み許可状態にします．
初期化が完了したら割込み待ちの無限ループに入ります．

\item コンソール割込み \\
ユーザがWRITEボタンを押して割込みが発生すると，
コンソール割込みルーチンが起動されます．
コンソール割込みルーチン中でブザーをONにした上でタイマをスタートします．

\item タイマ割込み \\
タイマがスタートして0.3秒後にタイマ割込が発生します．
タイマ割り込みルーチンではブザーをOFFにしてタイマを停止します．

\end{enumerate}

\begin{figure}[bt]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント\\
\hline
BUZ    & EQU    & 00H               & ; ブザーポート  \\
TMRVCT & EQU    & 0DCH              & ; TMR割込みベクタ  \\
CONVCT & EQU    & 0DFH              & ; CON割込みベクタ  \\
TMRCNT & EQU    & 4                 & ; TMR（周期）  \\
TMRCTR & EQU    & 5                 & ; TMRコントロール  \\
CONCTR & EQU    & 6                 & ; CONコントロール  \\
START  & \multicolumn{3}{|l|}{; メインプログラム}     \\ 
       & LD     & SP,\#0DCH         & ; SP初期化  \\
       & LD     & G0,\#CONINT       & ; コンソール割込み  \\
       & ST     & G0,CONVCT         & ; ルーチン登録  \\
       & LD     & G0,\#01H          & ; コンソール割込み  \\
       & OUT    & G0,CONCTR         & ; 許可  \\
       & LD     & G0,\#TMRINT       & ; タイマ割込み  \\
       & ST     & G0,TMRVCT         & ; ルーチン登録  \\
       & LD     & G0,\#25           & ; 周期=0.3SEC  \\
       & OUT    & G0,TMRCNT         & ; タイマ周期セット  \\
       & EI     &                   &   \\
WAIT   & JMP    & WAIT              & ; 無限ループ  \\
%       &        &                   &   \\
       & \multicolumn{3}{|l|}{; コンソール割込みルーチン}       \\
CONINT & PUSHF  &                   & ; コンテキストを  \\
       & PUSH   & G0                & ; 保存する  \\
       & LD     & G0,\#01H          & ;   \\
       & OUT    & G0,BUZ            & ; BEEP ON  \\
       & LD     & G0,\#81H          & ;  \\
       & OUT    & G0,TMRCTR         & ; TIMER START  \\
       & POP    & G0                & ; コンテキストを  \\
       & POPF   &                   & ; 復旧する  \\
       & RETI   &                   & ; 戻る  \\
%       &        &                   &   \\
       & \multicolumn{3}{|l|}{; タイマ割込みルーチン}       \\
TMRINT & PUSHF  &                   & ; コンテキストを  \\
       & PUSH   & G0                & ; 保存する  \\
       & LD     & G0,\#00H          & ;   \\
       & OUT    & G0,BUZ            & ; BEEP OFF  \\
       & LD     & G0,\#00H          & ;  \\
       & OUT    & G0,TMRCTR         & ; TIMER STOP  \\
       & POP    & G0                & ; コンテキストを  \\
       & POPF   &                   & ; 復旧する  \\
       & RETI   &                   & ; 戻る  \\
\hline
\end{tabular}
\end{center}}
\caption{コンソール割込みプログラムの例}
\label{fig:chap6:cons}
\end{figure}

%----------------------------------------------------------------------------
\newpage  % フロートがあっても
~         % 無理やり改ページ
%----------------------------------------------------------------------------
\newpage
\section{入出力割込み}
\label{chap6:ioint}

%一般に，
CPUの処理速度と入出力装置の動作速度には大きな差があるので，
入出力装置を動かすときCPUは長い待ち状態になります．
入出力装置の動作完了を待って
CPUがループを回り続けるだけでは時間が勿体ないので，
その間に他の仕事ができる仕組みが望まれます．

そこで，
入出力装置は動作が完了したことを
CPUに割込みで知らせることができるように設計してあります．
キーボード，マウス，ハードディスク，ネットワーク等のほとんどの入出力装置が，
動作完了の割込みを発生する機構を持っています．
このような割込みを「入出力割込み」と呼びます．

\subsection{TeCの入出力割込み}
TeCはSIOから入出力割込みを発生することができます．
SIOからの割込みは，
文字を受信したとき発生する「受信割込み」と，
次の文字を送信可能になったとき発生する「送信割込み」の2種類があります．
これらの割込みを使用するかしないかは，
割込み許可ビットにより別々に制御できるようになっています．

\subsubsection{SIO受信割込み}
TeCのSIOは文字を受信したとき，
INT1割込みを発生することができます．
割込みの発生を許可する手順は次の通りです．

\begin{enumerate}
\item スタックポインタを初期化する．
\item INT1割込みベクタにSIO受信割込み処理ルーチンの番地を書き込む．
\item SIOの受信割込み許可ビットをONにする．
割込み許可ビットは，I/O 3番地の $b_6$ です．
（「\ref{sioport} I/Oポート」の「コントロール」参照）
\item EI命令でCPUの割込みを許可する．

\end{enumerate}

文字を受信するとINT1割込みが発生します．
受信した文字をI/Oマップ3番地のSIO受信データレジスタ
（「\tabref{chap5:iomap} I/Oマップ」参照）から
読み出すことでINT1割込みが解除されます．

%データを読み出さないで割込み処理ルーチンから戻ると，
%再度，割込み処理ルーチンが呼び出されるので注意してください．

\subsubsection{SIO送信割込み}

TeCのSIOは文字を送信することが可能なときINT2割込みを発生することができます．
割込みの発生を許可する手順は次の通りです．

\begin{enumerate}
\item スタックポインタを初期化する．
\item INT2割込みベクタに，SIO送信割込み処理ルーチンの番地を書き込む．
\item SIOの送信割込み許可ビットをにONする．
割込み許可ビットはI/O 3番地の $b_7$ です．
（「\ref{sioport} I/Oポート」の「コントロール」参照）
\item EI命令でCPUの割込みを許可する．
\end{enumerate}

次の文字を送信することが可能になるとINT2割込みが発生します．
次に送信する文字をI/Oマップ3番地のSIO送信データレジスタ
（「\tabref{chap5:iomap} I/Oマップ」参照）に書込みます．
これで割込みが解除されます．
%データを書き込まないで割込み処理ルーチンから戻ると，
%再度，割込み処理ルーチンが呼び出されるので注意してください．
これ以上，送信する文字が無い場合は，
割込み許可ビットをOFFにしてください．

%----------------------------------------------------------------------------
\subsection{入出力割込みの使用例}
SIOを割込み駆動で使用する例を示します．

\subsubsection{SIO送信割込みの使用}
\figref{chap6:sioout}にローマ字で自分の名前を出力するプログラムの例を示します．
%「\reidairef{5_7} 文字列出力1」，
%「\reidairef{6_3} 文字列出力（改良版1）」 ，
「\reidairef{6_4} 文字列出力（改良版２）」等と同様なことを
割込みを使用して行います．
プログラムの動きは次の通りです．

\begin{enumerate}
\item メインルーチンで割込みを許可すると，
すぐに最初の割込みが発生する．
\item 割込み処理ルーチンの中で最初の文字をSIOデータレジスタに書き込む．
\item その後は1文字の送信が終了する度に割込みが発生するので，
割込み処理ルーチンの中でSIOデータレジスタに次の文字を書き込む．
\item 全ての文字を送信したらSIOの送信割込み許可ビットをOFFにし，
それ以上の割込みが発生しないようにする．
\end{enumerate}

この例では，
メインルーチンは出力が終了するまでループを回りながら待つだけですが，
本来は，出力は割込みに任せて，
%メインルーチンは
他の
%意味がある
処理を行うことができます．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント  \\
\hline
%        & \multicolumn{3}{|l|}{;注意！このプログラムは，タイマ割込み}  \\
%        & \multicolumn{3}{|l|}{;が発生することを考慮していない．実行時}  \\
%        & \multicolumn{3}{|l|}{;はハンダ付け練習基板を取り外すこと．}  \\
INT2V   & EQU   & 0DEH               &                   \\
SIOD    & EQU   & 02H                &                   \\
SIOC    & EQU   & 03H                &                   \\
%        &       &                    &                   \\
        & \multicolumn{3}{|l|}{;メインプログラム}        \\
START   & LD    & SP,\#0DCH          & ; SP初期化        \\
        & LD    & G0,\#SIOXINT       & ; 割込みルー      \\
        & ST    & G0,INT2V           & ; チンを登録      \\
        & LD    & G0,\#80H           & ; SIO 送信割      \\
        & OUT   & G0,SIOC            & ; 込み許可ON      \\
        & LD    & G0,\#DATA          & ; データの位      \\
        & ST    & G0,POINTER         & ; 置をセット      \\
        & LD    & G0,\#1             & ; 出力中Flag      \\
        & ST    & G0,FLAG            & ; セット          \\
        & EI    &                    & ; 割込み許可      \\
LOOP    & LD    & G0,FLAG            & ; 出力中フラ      \\
        & CMP   & G0,\#0             & ; グがクリア      \\
        & JZ    & END                & ; で終了          \\
        & JMP   & LOOP               & ; 割込み待ち      \\
END     & HALT  &                    &                   \\
        &       &                    &                   \\
DATA    & DC    & "SHIGEMURA"        &                   \\
        & DC    & 0                  &                   \\
%        &       &                    &                   \\
        & \multicolumn{3}{|l|}{; SIO送信割込み処理ルーチン}\\
SIOXINT & PUSHF &                    &                   \\
        & PUSH  & G0                 &                   \\
        & PUSH  & G1                 &                   \\
        & LD    & G1,POINTER         & ; 一文字          \\
        & LD    & G0,0,G1            & ; 取り出す        \\
        & CMP   & G0,\#0             & ; 文字列の        \\
        & JZ    & OWARI              & ; 終わりか？      \\
        & OUT   & G0,SIOD            & ; 送信する        \\
        & ADD   & G1,\#1             & ; 次の文字        \\
        & ST    & G1,POINTER         & ; に進める        \\
        & JMP   & KAERI              &                   \\
OWARI   & LD    & G0,\#00H           & ; SIO送信割       \\
        & OUT   & G0,SIOC            & ; 込み許可OFF     \\
        & ST    & G0,FLAG            & ; Flagクリア      \\
KAERI   & POP   & G1                 &                   \\
        & POP   & G0                 &                   \\
        & POPF  &                    &                   \\
        & RETI  &                    &                   \\
%        &       &                    &                   \\
        & \multicolumn{3}{|l|}{; 割込み処理ルーチンのデータ} \\
POINTER & DS    & 1                  & ; 文字列位置      \\
FLAG    & DS    & 1                  & ; 動作中FLAG    \\
%        &       &                    &                   \\
\hline
\end{tabular}
\end{center}}
\caption{SIO送信割込みの使用例}
\label{fig:chap6:sioout}
\end{figure}

\subsubsection{SIO受信割込みの使用}
\figref{chap6:sioin}に，
SIOから受信した文字（アルファベット小文字）によって，
ブザーが鳴る間隔が変化するプログラムを示します．
'a'よりも'b'が，'b'よりも'c'が，長い間隔になります．
'z'はプログラムを終了します．
\figref{chap6:sioin}では省略していますが，
「\ref{ms200} 0.2秒タイマ」で作成したMS200サブルーチンを利用します．
実際に実行する場合はMS200サブルーチンも打ち込んで下さい．

\begin{figure}[btp]
{\small\tt\begin{center}
\begin{tabular}{|l|l l l|} \hline
ラベル & \multicolumn{2}{|c}{ニーモニック} & コメント  \\
\hline
INT1V   & EQU     & 0DDH           & \\
BUZZ    & EQU     & 00H            & \\
SIOD    & EQU     & 02H            & \\
SIOC    & EQU     & 03H            & \\
%        &       &                    &                   \\
        & \multicolumn{3}{|l|}{;メインプログラム}        \\
START   & LD      & SP,\#0DCH      & ; SP初期化\\
        & LD      & G0,\#SIORINT   & ; 割込みルーチン\\
        & ST      & G0,INT1V       & ; を登録\\
        & LD      & G0,\#40H       & ; SIO 受信割込み\\
        & OUT     & G0,SIOC        & ; 許可ビットON\\
        & LD      & G0,\#'a'       & ; 最後に入力した\\
        & ST      & G0,IKEY        & ; 文字='a'\\
        & EI      &                & ; 割込み許可\\
LOOP    & LD      & G0,IKEY        & ; \\
        & ST      & G0,KEY         & \\
        & CMP     & G0,\#'z'       & ; 'z'が入力され\\
        & JZ      & END            & ; たら終了\\
        & LD      & G0,\#'a'       & \\
L1      & CALL    & MS200          & ; 200MS 待ち\\
        & CMP     & G0,KEY         & \\
        & JZ      & L2             & \\
        & ADD     & G0,\#1         & \\
        & JMP     & L1             & ; 割込み待ち\\
L2      & LD      & G0,\#1         & \\
        & OUT     & G0,BUZZ        & ; ブザーON\\
        & LD      & G0,\#'a'       & \\
L3      & CALL    & MS200          & \\
        & CMP     & G0,KEY         & \\
        & JZ      & L4             & \\
        & ADD     & G0,\#1         & \\
        & JMP     & L3             & \\
L4      & LD      & G0,\#0         & \\
        & OUT     & G0,BUZZ        & ; ブザーOFF\\
        & JMP     & LOOP           & \\
END     & HALT    &                & \\
%        &       &                    &                   \\
KEY     & DS      & 1              & \\
IKEY    & DS      & 1              & \\
%        &       &                    &                   \\
        & \multicolumn{3}{|l|}{;SIO受信割込み処理ルーチン} \\
SIORINT & PUSHF   &                & \\
        & PUSH    & G0             & \\
        & IN      & G0,SIOD        & ; 入力した文字を\\
        & ST      & G0,IKEY        & ; IKEYに格納する\\
        & POP     & G0             & \\
        & POPF    &                & \\
        & RETI    &                & \\
%        &       &                    &                   \\
\hline
\end{tabular}
\end{center}}
\caption{SIO受信割込みの使用例}
\label{fig:chap6:sioin}
\end{figure}

%----------------------------------------------------------------------------
%\begin{figure}[btp]
%\begin{framed}{\parindent=1em
%\subsection*{入出力装置とCPUの速度差}
%
%一般に，CPUに比較して入出力装置はデータの処理に長い時間がかかります．
%例えば TeC の SIO （「\ref{sio} TeCのシリアル入出力」参照）は
%$9,600bau$で動作するので，
%1文字を入出力するのに約1msの時間が必要です．
%1msはTeCの$2,458$ステートに相当します（「\ref{ms} 1msタイマ」参照）．
%1機械語命令が平均5ステートだと仮定すると，
%約$491$命令を実行できる時間になります．
%$491$命令分の時間を
%SIOの{\bf 動作が完了}したか調べるだけのループで費すのは勿体ないことです．
%その間に別の仕事をできる工夫が望まれます．
%}\end{framed}
%\end{figure}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\newpage
\section{マシンステートとスピーカ}

TeCには音を鳴らすためのスピーカが準備されています．
スピーカにはOUT命令でアクセスします．
ここではマシンステートを意識したプログラミングを行いスピーカを鳴らします．

%----------------------------------------------------------------------------
\subsection{スピーカーの仕組み}
\figref{chap6:spk}に示すようにI/Oアドレス1番地
（「\tabref{chap5:iomap} I/Oマップ」参照）の
LSB（$b_0$）には1ビットのレジスタが存在します．
このレジスタの1/0によりスピーカに加わる電圧が変化するようになっています．
なお，図では省略しましたが
「\ref{out} OUT（Output）命令」で紹介した「ブザー音源」も
同じスピーカに接続されています．

\myfigureN{btp}{scale=0.8}{spk.pdf}{スピーカの回路}{chap6:spk}

\figref{chap6:spk1}にスピーカの構造を示します．
加えた電圧により振動板が前後に移動します．
レジスタの値を$1,0,1,0,1,0,1,0$と変化させることにより
振動板が前後に振動して音がでます．
1kHzの音を出したい時は
プログラムで$1,0$書き込みを1秒間に1000回（1000サイクル）行う必要があります．

\myfigureN{btp}{scale=0.8}{spk1.pdf}{スピーカの回路}{chap6:spk1}

%----------------------------------------------------------------------------
\subsection{スピーカ駆動プログラム}
プログラムで1秒間に1000回のペースで$1,0$を繰り返すためには，
時間を計って$1/2000$秒に1度
I/Oポートの書き換えが行われるようにする必要があります．
マシンステートを使用して時間を計り，
一定の時間毎にスピーカポートの0/1を書き換えるプログラムを作ります．
「\reidairef{6_6} 1kHzブザー」のようなプログラムになります．
書き換えの間隔によって音の高さが決まります．

%----------------------------------------------------------------------------
\begin{figure}[btp]
\begin{reidai}{1kHzブザー}{6_6}{\small
\begin{description}
\item[問題：] 
スピーカーから1kHzの音を出すプログラムを作りなさい．

\item[考え方：]
「\ref{ms} 1msタイマ」では，$1ms$のタイマを作りました．
今回の問題では，
半分の$0.5ms$毎にスピーカ出力の0/1を書き換えるようにします．

\item[フローチャート：]
次のようになります．

\begin{center}
\myincludegraphics{flowA.pdf}{scale=0.8}
\end{center}

\item[プログラム：]
若干のステート数の増減は誤差と考えて無視します．
プログラムは，次のようになります．

\end{description}

{\footnotesize\tt\begin{center}
\begin{tabular}{|c|l|l| l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{2}{c|}{ニーモニック} \\
\hline
00 &          &        &\multicolumn{2}{|l|}{; 1kHz ブザー} \\
01 &          & SPK    & EQU &    01H              \\
%00 &          &        &     &                     \\
00 & 1F DC    & START  & LD  &    SP,\#0DCH        \\
02 & B0 10    & LOOP   & CALL&    MS5              \\
04 & 17 01    &        & LD  &    G1,\#01H         \\
06 & C7 01    &        & OUT &    G1,SPK           \\
08 & B0 10    &        & CALL&    MS5              \\
0A & 17 00    &        & LD  &    G1,\#00H         \\
0C & C7 01    &        & OUT &    G1,SPK           \\
0E & A0 02    &        & JMP &    LOOP             \\
%10 &          &        &     &                     \\
10 &          &        &\multicolumn{2}{|l|}{; 0.5ms サブルーチン} \\
10 & D0       & MS5    & PUSH&    G0               \\
11 & 13 57    &        & LD  &    G0,\#87          \\
13 & 43 01    & MATU   & SUB &    G0,\#1           \\
15 & A4 19    &        & JZ  &    KAERU            \\
17 & A0 13    &        & JMP &    MATU             \\
19 & D2       & KAERU  & POP &    G0               \\
1A & EC       &        & RET &                     \\
\hline
\end{tabular}
\end{center}}
}\end{reidai}
\end{figure}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
$200Hz$ブザーを作りなさい．
\vfill

%----------------------------------------------------------------------------
\newpage
\subsection{電子オルゴールプログラム}
スピーカ出力プログラムの応用として電子オルゴールプログラムを紹介します．
電子オルゴールプログラムでは曲の楽譜をデータとして準備します．
データは，音の高さを決めるためのループの繰り返し回数と，
音の長さを決めるためのループの繰り返し回数を組み合わせたものです．

%----------------------------------------------------------------------------
\subsubsection{フローチャート}
\figref{chap6:flowC}にフローチャートを示します．
プログラムは3重のループになっています．
最も内側の二つのループが，スピーカに1を出力している時間と，
0を出力している時間を計っています．
2番目のループの繰り返しにより音の継続時間を制御します．
最も外側のループは曲のデータを順番に取り出しています．

\myfigureN{btp}{scale=0.8}{flowC.pdf}
{電子オルゴールのアルゴリズム}{chap6:flowC}

\subsubsection{音符データ}
最も内側のループは20ステートあります．
このループの繰り返し回数で時間を計り
スピーカへの出力を音波の半サイクル毎に書き換えます．
スピーカへの出力と音波の関係を\figref{chap6:hakei}に示します．

\myfigureN{btp}{scale=0.8}{sound.pdf}
{0/1の出力と音波の関係}{chap6:hakei}

例えば「ラ」の音は$440Hz$ですので
半サイクルの時間は $2,457,600 / 440 / 2 = 2,792ステート$ になります．
半サイクルの時間をループで測るので
ループの繰り返し回数は，$2,792 / 20 = 139 = 8B_{16}回$ となります．
この値が音の高さを決めます．

音の長さは，音の出力を何サイクル行うかにより決めます．
例えば「ラ」の音は$440Hz$なので，
$220=DC_{16}サイクル$で$0.5秒$になります．
このプログラムでは，$0.5秒$を4分音符一つの時間としました．

「ラ」以外の音も同様に対応するデータ値を決めました．
\tabref{chap6:sound}に音データの一覧を示します．

\begin{mytable}{btp}{音データ一覧}{chap6:sound}
{\small\begin{tabular}{ l | c | l | l }
\hline\hline
音      & 周波数（Hz） & 長さ & 高さ \\
\hline
ド      & 262 & 83 & E8 \\
ド\#    & 277 & 8B & DD \\
レ      & 294 & 93 & D1 \\
レ\#    & 311 & 9C & C5 \\
ミ      & 330 & A5 & BA \\
ファ    & 349 & AF & AF \\
ファ\#  & 370& B9 & A6 \\
ソ      & 392 & C4 & 9C \\
ソ\#    & 415 & D0 & 93 \\
ラ      & 440 & DC & 8B \\
ラ\#    & 466 & E9 & 83 \\
シ      & 494 & F7 & 7C \\
ド      & 523 & FF & 75 \\
\end{tabular}}
\end{mytable}

%----------------------------------------------------------------------------
%\newpage
\subsubsection{プログラム}

\figref{chap6:doremi}に完成したプログラムとデータを示します．
プログラム中のORG命令は，
プログラムのアドレスを指定する命令です．
この場合，データを30H番地に生成するために使用しました．

このプログラムは，休符が表現できない，
同じ高さの音が連続すると一つの音になってしまう等の問題があります．
改良を考えて下さい．

\begin{figure}[btp]
{\footnotesize\tt\begin{center}
\begin{tabular}{|c|l|l|l l l|} \hline
番地 & 機械語 & ラベル & \multicolumn{3}{|c|}{ニーモニック} \\
\hline
01 &              &  SPK    & EQU    & 01H         &   \\
%00 &              &         &        &             &   \\
00 &              &         & \multicolumn{3}{|l|}{; 電子オルゴール}\\
00 & 17 2E        &         & LD     & G1,\#TABLE-2&   \\
02 & 37 02        &  L9     & ADD    & G1,\#2      &   \\
04 & 19 00        &         & LD     & G2,0,G1     &   \\
06 & 5B 00        &         & CMP    & G2,\#0      &   \\
08 & A4 2C        &         & JZ     & L16         &   \\
0A & 11 01        &  L10    & LD     & G0,1,G1     &   ; 7\\
0C & 00           &  L11    & NO     &             &   ; 3\\
0D & 00           &         & NO     &             &   ; 3\\
0E & 43 01        &         & SUB    & G0,\#1      &   ; 5\\
10 & A4 14        &         & JZ     & L12         &   ; 4/5\\
12 & A0 0C        &         & JMP    & L11         &   ; 5\\
14 & 13 01        &  L12    & LD     & G0,\#01H    &   ; 5\\
16 & C3 01        &         & OUT    & G0,SPK      &   ; 8\\
18 & 11 01        &  L13    & LD     & G0,1,G1     &   ; 7\\
1A & 00           &  L14    & NO     &             &   ; 3\\
1B & 00           &         & NO     &             &   ; 3\\
1C & 43 01        &         & SUB    & G0,\#1      &  ; 5\\
1E & A4 22        &         & JZ     & L15         &   ; 4/5\\
20 & A0 1A        &         & JMP    & L14         &   ; 5\\
22 & 13 00        &  L15    & LD     & G0,\#00H    &   ; 5\\
24 & C3 01        &         & OUT    & G0,SPK      &   ; 8\\
26 & 4B 01        &         & SUB    & G2,\#1      &  ; 5\\
28 & A4 02        &         & JZ     & L9          &   ; 4/5\\
2A & A0 0A        &         & JMP    & L10         &   ; 5\\
2C & FF           &  L16    & HALT   &             &   \\
%2D &              &         &        &             &   \\
2D &              &         & \multicolumn{3}{|l|}{; ドレミの歌} \\
30 &              &  TABLE  & ORG    & 30H         &   \\
30 & C5 E8        &         & DC     & 0C5H,0E8H   &   ; ド\\
32 & 49 D1        &         & DC     & 049H,0D1H   &   ; レ\\
34 & F7 BA        &         & DC     & 0F7H,0BAH   &   ; ミ\\
36 & 41 E8        &         & DC     & 041H,0E8H   &   ; ド\\
38 & A5 BA        &         & DC     & 0A5H,0BAH   &   ; ミ\\
3A & 83 E8        &         & DC     & 083H,0E8H   &   ; ド\\
3C & A5 BA        &         & DC     & 0A5H,0BAH   &   ; ミ\\
3E & A5 BA        &         & DC     & 0A5H,0BAH   &   ; ミ\\
40 & DC D1        &         & DC     & 0DCH,0D1H   &   ; レ\\
42 & 52 BA        &         & DC     & 052H,0BAH   &   ; ミ\\
44 & 57 AF        &         & DC     & 057H,0AFH   &   ; ファ\\
46 & 57 AF        &         & DC     & 057H,0AFH   &   ; ファ\\
48 & 52 BA        &         & DC     & 052H,0BAH   &   ; ミ\\
4A & 49 D1        &         & DC     & 049H,0D1H   &   ; レ\\
4C & AF AF        &         & DC     & 0AFH,0AFH   &   ; ファ\\
4E & AF AF        &         & DC     & 0AFH,0AFH   &   ; ファ\\
50 & AF AF        &         & DC     & 0AFH,0AFH   &   ; ファ\\
52 & AF AF        &         & DC     & 0AFH,0AFH   &   ; ファ\\
54 & F7 BA        &         & DC     & 0F7H,0BAH   &   ; ミ\\
56 & 57 AF        &         & DC     & 057H,0AFH   &   ; ファ\\
58 & C4 9C        &         & DC     & 0C4H,09CH   &   ; ソ\\
5A & 62 9C        &         & DC     & 062H,09CH   &   ; ソ\\
5C & 52 BA        &         & DC     & 052H,0BAH   &   ; ミ\\
5E & C4 9C        &         & DC     & 0C4H,09CH   &   ; ソ\\
60 & A5 BA        &         & DC     & 0A5H,0BAH   &   ; ミ\\
62 & C4 9C        &         & DC     & 0C4H,09CH   &   ; ソ\\
64 & C4 9C        &         & DC     & 0C4H,09CH   &   ; ソ\\
66 & 00           &         & DC     & 000H        &   ; 終了\\
%67 &              &         &        &             &   \\
\hline
\end{tabular}
\end{center}}
\caption{電子オルゴールプログラム}
\label{fig:chap6:doremi}
\end{figure}

%----------------------------------------------------------------------------
\newpage
\section{まとめ}

この章では，教育用コンピュータTeCの少し高度な機械語プログラミングを学びました．
クロス開発環境を用いてアセンブラで機械語を作成することを前提にしました．

前の章で扱ったのは，ノイマン型コンピュータに最低限必要な機能でした．
それに対し，この章では，スタック，サブルーチン，割込み等，
ノイマン型コンピュータを実用的に使用するために必要な機能を扱いました．

また，マシンステートやジャンプテーブルの利用，数値の入出力等，
プログラミングを行う上でよく使用されるテクニックも紹介しました．
