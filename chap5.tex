\chapter{機械語プログラミング\label{prog1}}
この章では，TeCのプログラミングを学習します．
まず，TeCの内部構成を勉強し，
ノイマン型コンピュータの例として，
TeCが適切であることを確認します．
次に，TeCの命令と，
それを使用したプログラムの作成を勉強します．
この章の内容をマスターすれば，
ノイマン型コンピュータがどのようなもので，
何ができて何ができないのか分かってきます．

%=============================================================================
\section{コンピュータの構成}
% プログラミングを始める前に，
プログラミングの対象となるコンピュータの構成を確認します．
ここでは，一般のコンピュータの構成と，TeCの構成の両方を説明します．
TeCの構成は一般のコンピュータの構成を簡単化したもので，
原理的には同じものだと分かります．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{一般的なコンピュータの構成}
一般的にパソコン等の構成は，
\figref{chap5:kousei1}のようになっています．
各部分の役割は次の通りです．

\myfigureN{tbp}{width=\columnwidth}{Tikz/kousei1.pdf}
          {一般的なコンピュータの構成}{chap5:kousei1}

\begin{enumerate}
\item CPU（Central Processing Unit:中央処理装置） \\
  命令を読み込んで，命令に従い計算をするコンピュータの心臓部です．
  計算機能，制御機能を持っています．
  CPUが他の部分に積極的に働きかけることにより，コンピュータが働きます．
\item 主記憶装置（メモリ） \\
  プログラムやデータを記憶する記憶装置です．
  CPUが高速に読み書きすることができます．
\item 入出力インタフェース \\
  入出力装置をコンピュータに接続するための回路です．
  入出力装置の種類毎に専用のインターフェース回路が必要になります．
  %（キーボード用のインタフェース回路，ディスプレイ用のインタフェース回路）
\item 入出力装置 \\
  時計やコンピュータの外部とデータのやりとりをする装置のことです．
  タイマ，キーボード，マウス，ディスプレイ，
  プリンタや通信装置等がこれにあたります．
  ハードディスクドライブやUSBメモリ等も入出力装置の仲間ですが，
  データを記憶する装置なので少し性格が異なります．
  そこで，これらは補助記憶装置と呼ばれることがあります．
\item バス \\
  CPUと主記憶装置や入出力インタフェースを接続する配線のことです．
  アドレスやデータ，制御信号等がバスで伝達されます．
  CPUはバスを制御することにより，
  バスに接続された装置とデータのやりとりをします．
\end{enumerate}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{TeCの構成}

TeCの構成は\figref{chap5:kousei2}のようになっています．
接続されている入出力装置が少ない，
主記憶装置（メモリ）の容量が小さい等の違いはありますが，
基本的には一般的なコンピュータの構成と同じです．

これらの大部分は，「\figref{chap4:kakubu} 各部の名称」で
「マイコン本体」と表示された正方形のLSIの内部に集積されています．
各部分の役割りは次の通りです．

\myfigureN{tbp}{width=\columnwidth}{Tikz/kousei2.pdf}
          {TeCの構成}{chap5:kousei2}

\begin{enumerate}
\item CPU \\
  命令を読み込んで命令に従い計算をするTeCの心臓部です．
  計算機能，制御機能を持っています．
  TeCのCPUは約30種類の命令を理解できます．
\item 主記憶装置（メモリ） \\
  TeCのメモリは，8ビット構成，256アドレスのものです．
  一つのアドレスに8ビットの情報を記憶することができます．
  0〜255（$00_{16}$〜$FF_{16}$）の範囲でアドレスを指定するためには，
  アドレス情報も8ビット必要ですので，8ビットアドレスと呼ぶこともあります．
\item 入出力インタフェース \\
  インターフェース回路を通してバスと入出力装置が接続されます．
\item 入出力装置 \\
  入出力装置として，タイマ，シリアル通信回路，スピーカ，
  コンソールパネルのデータスイッチ，入出力ポートが搭載されています．
\item バス \\
  CPUと主記憶装置や入出力インタフェースの間で次の情報を伝達します．
  \begin{enumerate}
  \item 8ビットのアドレス
  \item 8ビットのデータ
  \item いくつかの制御情報
  \end{enumerate}
\end{enumerate}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{TeC内部の記憶装置}
コンピュータはプログラムを実行するために内部に2進数で情報を記憶します．
TeCが内部に持っている記憶装置を\figref{chap5:naibu}にまとめます．
プログラムは主記憶（メモリ）に記憶されます．
CPUは主記憶（メモリ）からプログラム中の命令を読み込んで，
フラグやレジスタを使用しながら計算をします．

\myfigureN{tbp}{width=\columnwidth}{chap4/naibu.pdf}
          {TeCの記憶装置}{chap5:naibu}

\begin{enumerate}
\item フラグ \\
  \figref{chap5:kousei2}の「CPU」内部にあります．
  計算を行う度に，結果の特徴（ゼロだった等）を記録し条件判断に利用します．
\item レジスタ \\
  \figref{chap5:kousei2}の「CPU」内部にあります．
  各レジスタの役割は図中の表に示した通りです．
\item 主記憶（メモリ） \\
  \figref{chap5:kousei2}の「主記憶装置（メモリ）」のことです．
  256アドレス（256バイト）の容量があります．
  ここにプログラムやデータを記憶します．
\end{enumerate}

%=============================================================================
\newpage
\section{機械語プログラミング}
機械語命令の羅列が機械語プログラムです．
機械語プログラムを作る作業が機械語プログラミングです．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{機械語命令}
コンピュータのCPUは，メモリから命令を取り出し，
取り出した命令を解釈し，決められた計算等を行います．
CPUが解釈できる状態の命令を，
「CPU＝機械」が解釈できる命令なので\emph{「機械語命令」}と呼びます．
機械語命令は2進数でメモリに書き込みます．

2進数を用いた機械語の表現方法だけでは人間にとって分かり難いので，
命令を意味する英語を簡略化した短い綴で表します．
これを\emph{「ニーモニック」}と呼びます．

{\ttfamily\small\begin{center}
  \begin{tabular}{|c|c|c|} \hline
    機械語命令 & ニーモニック & 意味\\
    \hline
    $0000~0000_{2}$ & NO & No Operation \\
    $1111~1111_{2}$ & HALT & Halt \\
    \hline
  \end{tabular}
\end{center}}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{ノイマン型コンピュータの特徴}
TeCもノイマン型コンピュータの一種です．
ノイマン型コンピュータの特徴として次の3点があげられますが，
これは，TeCにも当てはまります．
\begin{enumerate}
\item プログラム内蔵（ストアードプログラム）方式 \\
  データだけでなく，プログラムもメモリに記憶する方式です．
  TeCでもプログラムはメモリに書き込んで実行します．
\item 逐次実行 \\
  プログラムの命令をメモリのアドレス順に一つ一つ順番に実行することを言います．
\item 2進法 \\
  %コンピュータの内部では
  プログラムやデータの表現に2進数を使います．
\end{enumerate}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{機械語プログラミング}
ノイマン型コンピュータ上での機械語プログラミングとは，
逐次実行により実行される順に機械語命令の羅列を作る作業のことです．
作ったプログラムは，2進数にしてメモリに書き込んで実行します．

TeCにどのような機械語命令があるかを，
次の節から種類別に説明します．

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{命令表}
      TeCでどんな機械語命令が使用できるかは，
      本体のケースに張り付けた命令表
      （または，「\figref{appC:insttbl} TeC7命令表」）により確認することができます．
      これまでに出てきたNO，HALT命令について，
      命令表を確認して下さい．
      ニーモニックと命令の名前，命令のフォーマットが分かりますね．

      その他にも，まだ習っていない情報がたくさん掲載されています．
      一通り勉強が終わったら，
      この命令表だけでTeCを自由にプログラミングできるようになります．
  }\end{framed}
\end{figure}

%=============================================================================
\newpage
\section{特殊な命令}
TeCの機械語命令の中で特別なものから説明します．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{NO（No Operation）命令}
\begin{description}
\item[意味：]何もしない命令です．

\item[ニーモニック：]\texttt{NO}

\item[命令フォーマット：] NO命令は1バイト長の命令です．
  命令フォーマットは，次の図の通りです．

  \oneByte{$0000_2$}{$00_2$~$00_2$}

  命令フォーマットの図は，
  その機械語命令が2進数でどのように表現されるかを表しています．
  NO命令の場合，機械語が1バイトであること，その1バイトの内容が，
  OPフィールド4ビットが$0000_2$，
  GRフィールド2ビットが$00_2$，
  XRフィールド2ビットが$00_2$であることが，
  図から分かります．
  NO命令以外の命令も，フィールドのビット数は同じです．
\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{HALT（Halt）命令}
\begin{description}
\item[意味：]プログラムの実行を停止します．

\item[ニーモニック：]\texttt{HALT}

\item[命令フォーマット：]1バイト長の命令です．

  \oneByte{$1111_2$}{$11_2$~$11_2$}

\end{description}

%=============================================================================
\newpage
\section{データ転送命令}
TeCのCPUとメモリの間でデータを転送する機械語命令を説明します．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{LD（Load）命令}
Loadは，「荷物等を積み込む」と言う意味の英語です．
LDは，Loadの綴を縮めたものです．

\begin{description}
\item[意味：]主記憶（メモリ）からレジスタへデータを転送します．
  （メモリからレジスタへ値をコピーします．メモリの値は変化しません．） 

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{LD  GR,EA} \\
  \texttt{GR}は，転送先レジスタを表します．
  \texttt{EA}はデータの置いてあるメモリのアドレス（番地）を表します．

\item[命令フォーマット：]LD命令は2バイトの長さを持ちます．
  命令の各ビットは次の通りです．

  \twoByte{$0001_2$}{\GR~\XR}{\A}

  \begin{itemize}
  \item OPフィールド（4ビット）はLD命令を示す$0001_2$にします．
  \item GRフィールド（2ビット）はデータを格納するレジスタを表します．
    GRフィールド意味を\tabref{chap5:gr}にまとめます．

    \begin{mytable}{btp}{GRフィールドの値と意味}{chap5:gr}
      {\small\begin{center}
        \begin{tabular}{c|c} \hline\hline
          GR & 意味 \\
          \hline
          $00_2$ & G0 \\
          $01_2$ & G1 \\
          $10_2$ & G2 \\
          $11_2$ & SP \\
        \end{tabular}
      \end{center}}
    \end{mytable}

  \item XRフィールド（2ビット）は，
    第2バイトと合わせて\texttt{EA}（メモリアドレス）を表しますが，
    将来，詳しく説明するまでは常に$00_2$にします．

  \item 第2バイト（\A）は，
    XRフィールドと合わせて\texttt{EA}（メモリアドレス）を表しますが，
    今のところ，直接にメモリアドレスを表していると考えて下さい．
  \end{itemize}

\item[フローチャート：]フローチャートでは，LD命令を次のように描きます．
  \texttt{[} と \texttt{]}を書き忘れないように，注意して下さい．

  \begin{center}
    \myincludegraphics{Tikz/ld.pdf}{scale=0.8}
  \end{center}

\item[使用例：]LD命令を使用したプログラムの例を示します．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      $00_{16}$ & $10_{16}$ $05_{16}$ & & LD   & G0,05H \\
      $02_{16}$ & $14_{16}$ $06_{16}$ & & LD   & G1,06H \\
      $04_{16}$ & $FF_{16}$           & & HALT &       \\
      \hline
    \end{tabular}
  \end{center}}

  例の中で機械語は16進数で書いてありますが，
  2進数に変換すると0番地の命令は $0001~0000_2$，$0000~0101_2$です．
  上の命令フォーマットと対応を確認してください．

  このプログラムをフローチャートで表現すると，
  次のようになります．

  \begin{center}
    \myincludegraphics{Tikz/lds.pdf}{scale=0.8}
  \end{center}
\end{description}

%----------------------------------------------------------------------------
\begin{figure}[tbp]
  \begin{framed}{\parindent=1em
      \subsection*{RUNランプが点滅したら}
      CPUが機械語命令として解釈できない命令を実行しようとしたことを表します．
      PCが解釈できなかった命令の次の番地を指した状態でCPUが停止します．
      PCの値からおかしな命令を見付けて訂正してください．
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}
    \subsection*{RUNランプに注意}{\parindent=1em
      RUNランプはプログラム実行中に点灯しています．
      プログラムが暴走し終了しない時は，
      RUNランプが点灯したままになります．
      プログラム実行中でも，
      コンソールパネルを操作してメモリやレジスタの値を表示できるので，
      プログラムが暴走していることに気づかないことがあります．
      RUNランプを常に気にするようにして下さい．
  }\end{framed}
\end{figure}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{ST（Store）命令}
Storeは，「倉庫に保管する」と言う意味の英語です．
STは，Storeの綴を縮めたものです．

\begin{description}
\item[意味：]レジスタからメモリへデータを転送します．
  （
    %レジスタからメモリへ値をコピーします．
    レジスタの値は変化しません．） 

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{ST  GR,EA} \\
  \texttt{GR}は，転送元レジスタを表します．
  \texttt{EA}はデータを保管するメモリのアドレス（番地）を表します．

\item[命令フォーマット：]ST命令は2バイトの長さを持ちます．
  命令のフォーマットは次の通りです．
  各フィールドの意味は，LD命令と同様です．

  \twoByte{$0010_2$}{\GR~\XR}{\A}

\item[フローチャート：]フローチャートでは，ST命令を次のように描きます．
  \texttt{[} と \texttt{]}を書き忘れないように，注意して下さい．

  \begin{center}
    \myincludegraphics{Tikz/st.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  5番地のデータを6番地にコピーして停止するプログラムの例を示します．
  番地と機械語の欄はいつも16進数で書くので，
  この例から小さく16と書くのを止めます．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 05 & & LD   & G0,05H \\
      02 & 20 06 & & ST   & G0,06H\\
      04 & FF    & & HALT & \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%----------------------------------------------------------------------------
\begin{figure}[tbp]
  \begin{framed}{\parindent=1em
      \subsection*{プログラムの作成手順}
      ST命令の使用例のように,
      表を作成しながらプログラムを書きます．
      手順は次の通りです．
      \begin{enumerate}
      \item 表の枠を書く．
      \item ニーモニックでプログラムを書く．
        プログラムに間違えが無いか，この段階で良く考える．
      \item 機械語命令の長さを考えながら番地欄を記入する．
        （これは，機械的な作業．ミスをしないよう慎重に．）
      \item 機械語欄を記入する．
        （これも，機械的な作業．ミスをしないように．）
      \item 全部記入したら，TeCに打ち込んで実行してみる．
      \item うまく動かなかったら，
        全てのステップを再度確認し間違えを探す．
      \item うまく動いたら完成！！！
        （うまく動いたかどうかの確認も慎重に！）
      \end{enumerate}

      表に記入したら終わりではありません．
      TeCに打ち込んで実際に動くことを確認してください．
      動くはずなのに動かないことが多い（まず，動かないと考えた方が良い）です．

      実際に動かし正しく動作することを確認できるまでは，
      プログラムは完成していません．
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
%以下では番地が16進数です．注意して下さい．
\begin{enumerate}
\item $11_{16}$番地のデータを$12_{16}$番地に，
  $10_{16}$番地のデータを$11_{16}$番地にコピーして停止するプログラムを
  書きなさい．
\item $10_{16}$番地のデータと$11_{16}$番地のデータを交換して
  停止するプログラム書きなさい．
\item これらのプログラムを，実際にTeCで実行して正しく動くことを確認しなさい．
\end{enumerate}
\vfill

%------------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{うまく動かない場合}
      プログラムが正しく動かない人は，
      1命令ずつ実行しながら，
      メモリやレジスタの値が予想通りに変化するか調べて下さい．
      1命令ずつ実行する方法は，%\ref{step}中の
      「プログラムのステップ実行」（p.\pageref{step}）に
      説明してあります．

      面倒くさいと思わないで，地道に問題点を捜しましょう．
      問題点を見つけるコツが分かってきたら，
      演習がすごく楽になります．
      慣れるまで少し辛抱して下さい．
  }\end{framed}
\end{figure}

%=============================================================================
\newpage
\section{算術演算命令}

名前の通り算術計算（普通の計算）をするための命令です．
TeCは足算と引算だけができます．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{ADD（Add）命令}
ADD命令は，名前の通り，加算（足算）をします．

\begin{description}
\item[意味：]レジスタの値とメモリデータの和を計算し，
  結果を元のレジスタに格納します．（メモリの値は変化しません．）
  
\item[フラグ：]計算の結果により変化します．

\item[ニーモニック：]\texttt{ADD  GR,EA} \\
  \texttt{GR}は，足し算の対象になるレジスタを表します．
  このレジスタの値と\texttt{EA}で表されるメモリの値が足し合わされ，
  結果がこのレジスタに格納されます．

\item[命令フォーマット：]ADD命令は2バイトの長さを持ちます．
  命令の各フィールドの意味は，LD命令と同様です．

  \twoByte{$0011_2$}{\GR~\XR}{\A}

\item[フローチャート：]フローチャートでは，ADD命令を次のように描きます．
  \texttt{[} と \texttt{]}を書き忘れないように，注意して下さい．

  \begin{center}
    \myincludegraphics{Tikz/add.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  7番地のデータと8番地のデータの和を計算し，
  9番地に格納するプログラムの例を示します．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 07 & & LD   & G0,07H \\
      02 & 30 08 & & ADD  & G0,08H \\
      04 & 20 09 & & ST   & G0,09H \\
      06 & FF    & & HALT & \\
      \hline
    \end{tabular}
  \end{center}}

  このプログラムを実行するときは，
  予め7番地，8番地に足し合わせるデータを格納しておく必要があります．
  例えば，7番地に1，8番地に2を格納した状態でこのプログラムを実行すると，
  計算結果の3が9番地に格納されます．
\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{SUB（Subtract）命令}
Subtractは，「引き算をする」と言う意味の英語です．
SUBはSubtractの綴を縮めたものです．

\begin{description}
\item[意味：]レジスタの値とメモリデータの差を計算し，
  結果を元のレジスタに格納します．（メモリの値は変化しません．）

\item[フラグ：]計算結果により変化します．

\item[ニーモニック：]\texttt{SUB  GR,EA} \\
  \texttt{GR}は，引き算の対象になるレジスタを表します．
  このレジスタの値から\texttt{EA}で表されるメモリの値が引かれ，
  結果がこのレジスタに格納されます．

\item[命令フォーマット：]SUB命令は2バイトの長さを持ちます．
  命令の各フィールドの意味は，LD命令と同様です．

  \twoByte{$0100_2$}{\GR~\XR}{\A}

\item[フローチャート：]SUB命令は次のように描きます．
  \texttt{[} と \texttt{]}を書き忘れないように，注意して下さい．

  \begin{center}
    \myincludegraphics{Tikz/sub.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  7番地のデータから8番地のデータを引いた結果を
  9番地に格納するプログラムの例を示します．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 07 & & LD   & G0,07H \\
      02 & 40 08 & & SUB  & G0,08H \\
      04 & 20 09 & & ST   & G0,09H \\
      06 & FF    & & HALT & \\
      \hline
    \end{tabular}
  \end{center}}

  このプログラムを実行するときは，
  予め7番地に引かれる数，8番地に引く数を格納しておく必要があります．
\end{description}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
$10_{16}$番地のデータと$11_{16}$番地のデータの和を$12_{16}$番地に，
差を$13_{16}$番地に格納するプログラムを作成し，
TeCで実行して正しく実行できたことを確かめなさい．
\vfill

%=============================================================================
\newpage
\section{ジャンプ命令}
ノイマン型コンピュータの特徴は逐次実行です．
命令を番地の順に一つ一つ実行します．
プログラムの実行が進んで行く流れを\emph{「プログラムの流れ」}と言います．
プログラムの流れはPC（Program Counter）によって管理され，
通常はPCが順次増加します．

しかし，プログラムの同じ部分を繰り返したり，
条件によりプログラムの動きを変更する目的で，
流れを別の場所に飛ばすこと（Jump）も必要です．

ジャンプ命令はこのような目的でPCの値を変更し，
プログラムの流れを別の番地へ飛ばすものです．
プログラムの流れは飛んで行った先にあるプログラムを順番に実行する流れになり，
もとに戻って来ることはありません．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{JMP（Jump）命令}
この命令を実行するとプログラムの流れが，
必ず指定の番地にジャンプします．

\begin{description}
\item[意味：]プログラムの流れをジャンプさせます．
\item[フラグ：]変化しません．
\item[ニーモニック：]\texttt{JMP EA} \\
  \texttt{EA}はジャンプ先のアドレス（番地）を表します．

\item[命令フォーマット：]JMP命令は2バイトの長さを持ちます．
  GRフィールドは必ず$00_2$にします．
  XRフィールドと第2バイトでジャンプ先アドレス（\texttt{EA}）を表します．

  今のところ，XRフィールドは$00_2$にします．
  この場合は，第2バイトの値がジャンプ先アドレスになります．

  \twoByte{$1010_2$}{$00_2$~\XR}{\A}

\item[フローチャート：]JMP命令はフローチャートの線に対応します．
  次の命令で詳しく説明します．

\item[使用例：]
  $00_{16}$番地の命令を
  いつまでも繰り返す（止まらない）プログラムの例を示します．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 30 04 & & ADD  & G0,04H \\
      02 & A0 00 & & JMP  & 00H    \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%------------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{ラベル}
      JMP命令の使用例では，
      ジャンプする先のアドレスをニーモニックの中に数値で書きました．
      もしも，プログラムに変更があり，
      ジャンプする先のアドレスが変化したらどうでしょうか．
      プログラムにアドレスが数値で書いてあると，
      それを書き直す必要が生じます．

      アドレスが変化してもニーモニックで書いたプログラムを
      変更しなくて良いように，
      数値の代わりにそのアドレスに付けた記号を使うと便利です．

      アドレスに付けた記号のことをラベルと言います．
      ラベルを用いてプログラムを書き換えると次のようになります．

      {\ttfamily\small\begin{center}
        \begin{tabular}{|l|l|l|l l|} \hline
          番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
          \hline
          00 & 30 04 & \emph{LOOP} & ADD  & G0,04H     \\
          02 & A0 00 &            & JMP  & \emph{LOOP} \\
          \hline
        \end{tabular}
      \end{center}}
  }\end{framed}
\end{figure}

%------------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{データの定義（DC命令）}
      ラベルを用いることにより，
      ニーモニックで書いたプログラムの取扱いが非常に便利になりました．
      しかし，データの部分はニーモニックに記述できていません．
      これではニーモニックだけでプログラムの全体像が理解できません．

      そこで，
      データを記述するための``DC（Define Constant）''命令を追加します．
      DC命令は，機械語の代わりにオペランドで指定した値のデータを生成します．
      また，
      DC命令の行にラベルを付けることにより
      データもラベルで参照できるようになります．

      次は，JMP命令の使用例をDC命令を用いて書き直したものです．
      4番地に値``1''のデータがあることが，
      ニーモニックで記述できました．

      {\small\ttfamily\begin{center}
        \begin{tabular}{|l|l|l|l l|} \hline
          番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
          \hline
          00 & 30 04 & LOOP       & ADD  & G0,\emph{ONE}  \\
          02 & A0 00 &            & JMP  & LOOP          \\
          04 & 01    & \emph{ONE}  & DC   & 1             \\
          \hline
        \end{tabular}
      \end{center}}
  }\end{framed}
\end{figure}

%------------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{領域の定義（DS命令）}
      DS命令はDC命令に良く似た命令です．
      DC命令は機械語命令の代わりにデータを生成しました．
      DS命令は結果を格納するための領域を生成します．
      指定された数値は領域の大きさになります．
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{フラグ}
      いくつかのプログラムを作成して動かして見ました．
      そのとき，
      TeCのC，S，Zランプが点灯したり消灯したりしたのが分かったでしょうか？

      これらのランプは，対応したフラグ（Flag：旗）の値を表示しています．
      どんなときランプが点灯し（フラグが1になり），
      どんなときランプが消灯した（フラグが0になった）のか説明します．

      \begin{description}
      \item[C（Carry）フラグ]
        Carryは「桁を繰り上げる」と言う意味です．
        Cフラグは，
        計算中に8bitの最上位桁からの「桁上がり」や，
        8bitの最上位桁での「桁借り」が発生したことを表します．
        つまり，計算結果が255を超えてしまったことや，
        0より小さくなったことを表します．
        Cフラグは，計算値が符号無しと考えたときのオーバーフローを表しています．
      \item [S（Sign）フラグ]
        Signは，\emph{「符号」}を意味します．
        計算の結果を符号付き2進数として解釈した場合，
        負の値になることを表します．
        つまり，計算結果の8bitの最上位ビットが1のとき1になります．
      \item [Z（Zero）フラグ]
        Zeroは，名前の通り計算の結果がゼロになったことを表します．
        つまり，計算結果の8bitの全てのビットが0のとき1になります．
      \end{description}

      これら三つのフラグは，
      命令表（\figref{appC:insttbl}）で
      「フラグ変化」の欄に「○」印が付いている演算命令を実行する度に
      計算結果によって変化します．
      つまり，直前の演算の結果を反映しています．
      これまでに出てきた命令では，ADD，SUBがフラグを変化させる命令です．
  }\end{framed}
\end{figure}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{JZ（Jump on Zero）命令}
Zフラグが1のとき（計算結果が0だったとき）だけジャンプします．

\begin{description}
\item[意味：]Zフラグが1ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{JZ EA} \\
  JMP命令と同様です．

\item[命令フォーマット：]JZ命令は2バイトの長さを持ちます．
  GRフィールドは必ず $01_2$にします．
  GRフィールド以外の意味はJMP命令と同じです．

  \twoByte{$1010_2$}{$01_2$~\XR}{\A}

\item[フローチャート：]JZ命令のフローチャートは，
  次のように様々な描き方が考えられます．
  例には，JMP命令と組合せて菱形一つに対応させたものもありますが，
  こだわる必要はありません．
  場合によって，柔軟にアレンジして下さい．

  \begin{center}
    \myincludegraphics{chap5/jz.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  結果がゼロだったら停止するプログラムの例を示します．
  定数の``1''を使用するためにDC命令でメモリの$07_{16}$番地に
  データ$01_{16}$を置きました．
  定数を使用するためにはメモリ上に定数データを置く必要があります．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 30 07 & LOOP & ADD  & G0,ONE  \\
      02 & A4 06 &      & JZ   & STOP    \\
      04 & A0 00 &      & JMP  & LOOP    \\
      06 & FF    & STOP & HALT &         \\
      07 & 01    & ONE  & DC   & 1       \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%----------------------------------------------------------------------------
%\begin{figure}[btp]
\begin{framed}{\parindent=1em
    \subsection*{Cフラグの詳しい説明}

    Cフラグは，
    計算中に，8bitの最上位桁からの「桁上がり（Carry）」が発生したことや，
    8bitの最上位桁での「桁借り（Borrow）」が発生したことを表します．
    例えば，次の計算では最上位桁からの「桁上がり」は発生しませんので，
    Cフラグは``0''になります．

    \begin{center}
      \begin{tabular}{ c l l}
        & $0000~0001_2$ & ($1$) \\
        $+$ & $0000~0011_2$ & ($3$) \\
        \cline{1-2}
        \fbox{$0$} & $0000~0100_2$ & ($4$) \\
        C  &                     \\
      \end{tabular}
    \end{center}

    次の計算では最上位桁からの「桁上がり」が発生し，Cフラグが``1''になります．
    Cフラグは，計算値が符号無しと考えたときのオーバーフローを表しています．

    \begin{center}
      \begin{tabular}{ c l r r }
        &               & 符号無   & 符号付 \\
        & $1111~1111_2$ & ($255$)  & ($-1$) \\
        $+$ & $0000~0001_2$ & ($1$)    & ($+1$)\\
        \cline{1-2}
        \fbox{$1$} & $0000~0000_2$ & (オーバ & ($0$) \\
        C   &               & フロー) & \\
      \end{tabular}
    \end{center}

    また，引き算でもCフラグが1になることがあります．
    例えば，次のように小さな数から大きな数を引いた場合です．
    機械的に引き算をすると，最上位桁で桁借りが発生します．
    この時も，Cフラグが1になります．

    \begin{center}
      \begin{tabular}{ c l r r }
        &               & 符号無 & 符号付 \\
        & $0110~0100_2$ & ($100$)  & ($+100$) \\
        $-$ & $0110~1110_2$ & ($110$)  & ($+110$)\\
        \cline{1-2}
        \fbox{$1$} & $1111~0110_2$ & (オーバ & ($-10$) \\
        C   &               & フロー) & \\
      \end{tabular}
    \end{center}

    引き算の場合，
    Cフラグは，計算が符号無しと考えたときの，
    負へのオーバーフローを表しています．
}\end{framed}
%\end{figure}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{JC（Jump on Carry）命令}
Cフラグが1のときだけジャンプします．

\begin{description}
\item[意味：]Cフラグが1ならジャンプします．
\item[フラグ：]変化しません．
\item[ニーモニック：]\texttt{JC  EA} \\
  JMP命令と同様です．
\item[命令フォーマット：]JC命令は2バイトの長さを持ちます．
  GRフィールドは必ず $10_2$にします．
  GRフィールド以外の意味はJMP命令と同じです．

  \twoByte{$1010_2$}{$10_2$~\XR}{\A}

\item[フローチャート：]JC命令のフローチャートは，
  JZ命令と同様な考えで描きます．
  JZ命令を参考にして下さい．

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{JM（Jump on Minus）命令}
Sフラグが1のとき（計算結果が負だったとき）だけジャンプします．
名前が，JS命令ではなくJM命令になっているので注意して下さい．

\begin{description}
\item[意味：]Sフラグが1ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{JM  EA} \\
  JMP命令と同様です．

\item[命令フォーマット：]JM命令は2バイトの長さを持ちます．
  GRフィールドは必ず $11_2$にします．
  GRフィールド以外の意味はJMP命令と同じです．

  \twoByte{$1010_2$}{$11_2$~\XR}{\A}

\item[フローチャート：]JM命令のフローチャートも，
  JZ命令と同様な考えで描きます．
  JZ命令を参考にして下さい．
\end{description}

%----------------------------------------------------------------------------
\subsection{ジャンプ命令の利用}

以下にジャンプ命令を使用して，
「条件判断を行う場合」と「繰り返し処理を行う場合」を説明します．
更にその後の例題を理解してから「問題」に挑戦して下さい．

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{条件判断1}
      ジャンプ命令を用いて，
      条件判断の機能があるプログラムを作ることができます．
      次のフローチャートとプログラムは，
      計算結果がゼロだった場合だけ処理をするものです．
      このように，ある条件の場合だけ処理をするプログラムを作ることができます．

      \begin{center}
        \myincludegraphics{Tikz/flow2A.pdf}{width=0.85\columnwidth}
      \end{center}
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{条件判断2}
      条件によって，
      二つの処理のどちらかを選んで実行するプログラムを作ることができます．
      次のフローチャートとプログラムは，
      計算結果がゼロだった場合は「処理1」を，
      ゼロ以外だった場合は「処理2」を実行します．

      \begin{center}
        \myincludegraphics{Tikz/flow2B.pdf}{width=0.85\columnwidth}
      \end{center}
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{繰り返し処理1}
      ジャンプ命令を用いて同じ操作を繰り返すプログラムを作ることができます．
      次のフローチャートとプログラムは，点線部分を10回繰り返すためのものです．

      \begin{center}
        \myincludegraphics{Tikz/flow2.pdf}{width=0.85\columnwidth}
      \end{center}
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{繰り返し処理2}
      計算結果によって繰り返し回数が決まる場合，
      繰り返し回数がゼロの場合も考慮しなければならないことがあります．
      そのような場合は，条件判断を前に移動すると，うまく処理できます．
      次のフローチャートとプログラムは，
      点線部分をN回繰り返すためのものです．
      条件判断の前の引算は，
      G0の値でフラグを強制的に変化させるためのものです．

      \begin{center}
        \myincludegraphics{Tikz/flow2C.pdf}{width=0.85\columnwidth}
      \end{center}
  }\end{framed}
\end{figure}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{絶対値を求める．}{5_1}
  \begin{description}

  \item[問題：]
    N番地のデータの絶対値を計算し，
    M番地に格納するプログラムを作りなさい．

  \item[考え方：]
    値が正なのか負なのかは，
    値からゼロを（SUB命令で）引き，
    そのときのフラグの変化で調べます．
    負の値の絶対値は，
    ゼロからその値を引くことで求めることができます．

  \item[解答：]次のようなプログラムを作ります．

    \begin{center}
      \myincludegraphics{Tikz/flow1.pdf}{width=0.95\columnwidth}
    \end{center}

    \begin{center}
      {\footnotesize\ttfamily
        \begin{tabular}{|l|l|l|l l|}
          \hline
          番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
          \hline
          00 & 10 10 & START& LD   & G0,N    \\
          02 & 40 0F &      & SUB  & G0,ZERO \\
          04 & AC 08 &      & JM   & L1      \\
          06 & A0 0C &      & JMP  & L2      \\
          08 & 10 0F & L1   & LD   & G0,ZERO \\
          0A & 40 10 &      & SUB  & G0,N    \\
          0C & 20 11 & L2   & ST   & G0,M    \\
          0E & FF    &      & HALT &         \\
          0F & 00    & ZERO & DC   & 0       \\
          10 & FF    & N    & DC   & -1      \\
          11 & 00    & M    & DS   & 1       \\
          \hline
        \end{tabular}
      }
    \end{center}

  \item[解説：]プログラムの内容を説明します．
    {\small
      \begin{description}
      \item[(1)] G0レジスタに値をロードします．
      \item[(2)] G0レジスタから0を引きます．
        %値は変化しませんが，
        計算結果によりフラグが変化します．
      \item[(3)] JM命令はSフラグの値によりジャンプします．
      \item[(4)，(5)] この部分は，値が負だった場合のみ実行されます．
        $0 - [N番地]$を計算し，値の絶対値をG0に求めます．
      \item[(6)] G0の値をM番地に格納します．
      \end{description}
    }

  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{$1 + 2 + 3 + ... + 10$を計算する．}{5_2}
  \begin{description}
  \item[問題：]
    $1 + 2 + 3 + ... + 10$を計算し結果をSUM番地に求めるプログラムを作りなさい．

  \item[考え方：]
    TeCではG0，G1，G2，SPの４つのレジスタが自由に使用できます．
    それぞれのレジスタに足す値を記憶する，
    合計を記憶する等の役割りを分担させ，
    繰り返し（10回繰り返す）をうまく利用すると計算できます．

    TeCにはレジスタの値同士を足し算する命令がありません．
    一方のレジスタ値をメモリに格納してから，足し算する必要があります．

  \item[解答：]
    G0を繰り返し回数のカウント，
    G1をレジスタに足す数の記憶（1，2，3，...，10），
    G2を合計の記憶に使用することにしました．
    SPは使用しませんでした．
    フローチャートとプログラムは次のようになります．

    \begin{center}
      \myincludegraphics{Tikz/flow3.pdf}{width=0.85\columnwidth}
    \end{center}
  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item N番地の値が0ならM番地に0を，
  そうでなければM番地に1を格納するプログラムを作りなさい．
\item N番地とM番地の値の大きい方をL番地に格納するプログラムを作りなさい．
\item N番地とM番地の値のかけ算を計算し，
  L番地に結果を格納するプログラムを作りなさい．\\
  ヒント：かけ算は足し算の繰り返しでできます．
%\item かけ算プログラムの改良 \\
  %前のプログラムを[N]または，
  %[M]がゼロのときでも正しく動くように改良しなさい．
\end{enumerate}
\vfill

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{JNZ（Jump on Not Zero）命令}
Zフラグが0のとき（計算結果がゼロ以外だったとき）だけジャンプします．

\begin{description}
\item[意味：]Zフラグが0ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{JNZ  EA} 
  %\\JMP命令と同様です．

\item[命令フォーマット：]JNZ命令は2バイトの長さを持ちます．
  GRフィールドは必ず $01_2$にします．
  OPフィールドの値は $1011_2$ です．
  JMP命令と違いますので注意して下さい．
  OPフィールド，GRフィールド以外の意味はJMP命令と同じです．

  \twoByte{$1011_2$}{$01_2$~\XR}{\A}

\item[フローチャート：]JNZ命令のフローチャートも，
  JZ命令と同様な考えで描きます．
  JZ命令を参考にして下さい．

\item[使用例：]
  JZ命令の\emph{使用例}で紹介した「結果がゼロだったら停止するプログラムの例」を
  JNZ命令を使用して書き直しました．
  JNZ命令を使用したほうが随分シンプルになります．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 30 05 & LOOP & ADD  & G0,ONE  \\
      02 & B4 00 &      & JNZ  & LOOP    \\
      04 & FF    &      & HALT &         \\
      05 & 01    & ONE  & DC   & 1       \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{JNC（Jump on Not Carry）命令}
Cフラグが0のときだけジャンプします．
%\\（\emph{注意：}TeC6では使用できない命令です．）

\begin{description}
\item[意味：]Cフラグが0ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{JNC  EA}
  % \\JMP命令と同様です．

\item[命令フォーマット：]JNC命令は2バイトの長さを持ちます．
  GRフィールドは必ず $10_2$にします．
  GRフィールド以外の意味はJNZ命令と同じです．

  \twoByte{$1011_2$}{$10_2$~\XR}{\A}

\item[フローチャート：]JNC命令のフローチャートも，
  JZ命令と同様な考えで描きます．
  JZ命令を参考にして下さい．

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{JNM（Jump on Not Minus）命令}
Sフラグが0のとき（計算結果がゼロか正だったとき）だけジャンプします．
名前が，JNS命令ではなくJNM命令になっているので注意して下さい．
%\\（\emph{注意：}TeC6では使用できない命令です．）

\begin{description}
\item[意味：]Sフラグが0ならジャンプします．

\item[フラグ：]変化しません．

\item[ニーモニック：]\texttt{JNM  EA}
  % \\JMP命令と同様です．

\item[命令フォーマット：]JNM命令は2バイトの長さを持ちます．
  GRフィールドは必ず $11_2$にします．
  GRフィールド以外の意味はJNZ命令と同じです．

  \twoByte{$1011_2$}{$11_2$~\XR}{\A}

\item[フローチャート：]JNM命令のフローチャートも，
  JZ命令と同様な考えで描きます．
  JZ命令を参考にして下さい．

\end{description}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item 「\reidairef{5_1} 絶対値を求める」プログラムを
  JNM命令を用いて書き直しなさい．

\item 「\reidairef{5_2} 1+2+3+...+10を計算する」プログラムを
  JNZ命令を用いて書き直しなさい．

\item N番地とM番地の値のかけ算を計算し，
  L番地に結果を格納するプログラムをJNZ命令を用いて作り直しなさい．

\item N番地とM番地の値の和を計算しL番地に結果を格納するプログラムを作りなさい．
  但し，オーバーフローが発生した場合は8bitで表現できる最大の値255をL番地に
  格納することとします．（数値は符号なし数とします．）\\
  参考：このような計算を飽和演算（ほうわえんざん）と言います．

\item 前の問題ではJC命令かJNC命令を使用したはずです．
  JC命令を使用していた場合はJNC命令，
  JNC命令を使用していた場合はJC命令を用いて作り直しなさい．
\end{enumerate}
\vfill

%=============================================================================
\newpage
\section{比較命令}
\label{comp}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{CMP（Compare）命令}
Compareは，「比較をする」と言う意味の英語です．
CMPはCompareの綴を縮めたものです．
比較は引き算により行います．
レジスタの値からメモリの値を引いて，
その結果によりフラグを変化させます．
引き算結果そのものは，どこにも格納しないで捨てます．

\begin{description}
\item[意味：]レジスタの値とメモリデータを比較します．
  引き算の結果により，フラグだけが変化します．

\item[フラグ：]計算結果により変化します．

\item[ニーモニック：]\texttt{CMP  GR,EA} \\
  \texttt{GR}で指定されたレジスタの値と，
  \texttt{EA}で表されるメモリの値が比較されます．

\item[命令フォーマット：]CMP命令は2バイトの長さを持ちます．
  各フィールドの意味は，LD命令と同様です．

  \twoByte{$0101_2$}{\GR~\XR}{\A}

\item[フローチャート：]CMP命令は次のように描きます．
  %\texttt{[ と ]}を書き忘れないように，注意して下さい．

  \begin{center}
    \myincludegraphics{Tikz/cmp.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  A，B二つのデータで大きい方を選んで，Cに格納するプログラムの例です．

  {\ttfamily\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 0D & START & LD   & G0,A \\
      02 & 50 0E &       & CMP  & G0,B \\
      04 & AC 08 &       & JM   & LB   \\
      06 & A0 0A &       & JMP  & LC   \\
      08 & 10 0E & LB    & LD   & G0,B \\
      0A & 20 0F & LC    & ST   & G0,C \\
      0C & FF    &       & HALT & \\
      0D & 64    & A     & DC   & 100  \\
      0E & C8    & B     & DC   & 200  \\
      0F & 00    & C     & DS   & 1    \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{割算を計算する．}{5_3}
  \begin{description}
  \item[問題：]
    M番地の値をN番地の値で割り，
    商をK番地，余りをL番地に求めるプログラムを作りなさい．

  \item[考え方：]
    TeCには割算命令がありません．
    割算は引き算の繰り返しで計算できます．
    割られる数から，割る数を引くことを繰り返します．
    引くことができなくなったら終了します．
    このとき，引いた回数が商，引いた結果が余りになります．

  \item[解答：]
    フローチャートとプログラムは次のようになります．\\

    \begin{center}
      \myincludegraphics{Tikz/flow5.pdf}{width=0.85\columnwidth}
    \end{center}

  \item[解説：]CMP命令とJM命令でG0がN番地のデータより大きいか
    確認してから，引き算を実行します．

  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item 「\reidairef{5_1} 絶対値を求める」プログラムを
  CMP命令を用いて書き直しなさい．

\item 「\reidairef{5_2} 1+2+3+...+10を計算する」プログラムを
  G0レジスタを使用しないプログラムに書き換えなさい．
  （CMP命令を用いると簡単にできる．）
\end{enumerate}
\vfill

%=============================================================================
\newpage
\section{シフト（桁ずらし）命令}
データの2進数を左右に桁移動する命令をシフト命令と言います．
TeCは以下に説明する4種類のシフト命令を持っています．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{SHLA（Shift Left Arithmetic）命令}
左算術（算術＝Arithmetic）シフトと言います．
レジスタのデータを左方向に1ビットずらします．
右側から常に``0''が入力されます．
左にはみ出したビットは，Cフラグの値になります．

\begin{center}
  \myincludegraphics{Tikz/shft1.pdf}{scale=0.8}
\end{center}

\begin{description}
\item[意味：]レジスタの値を左に1ビットシフトします．

\item[フラグ：]Cフラグは上の説明のように，
  S，Zフラグはシフト結果の値により変化します．

\item[ニーモニック：]\texttt{SHLA  GR} \\
  \texttt{GR}が，シフトされるレジスタを表します．
  \texttt{GR}の値とレジスタの対応は，LD命令等と同じです．

\item[命令フォーマット：]SHLA命令は1バイトの命令です．
  XRフィールドは必ず $00_2$にします．

  \oneByte{$1001_2$}{\GR~$00_2$}

\item[フローチャート：]SHLA命令は次のように描くことにします．
  なお，この書き方は，Java言語やC言語のシフト演算子を真似たものです．

  \begin{center}
    \myincludegraphics{Tikz/shla.pdf}{scale=0.8}
  \end{center}

\item[使用例：] SHLA命令は次のSHLL命令と全く同じ動作をしますので，
  SHLA命令とSHLL命令で兼用の使用例をSHLL命令の後に示します．

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{SHLL（Shift Left Logical）命令}
左論理（論理=Logical）シフトと言います．
この命令は SHLA と全く同じ動作をします．
（左シフトでは，算術と論理の差はない）

\begin{description}
\item[意味：]レジスタの値を左に1ビットシフトします．

\item[フラグ：]
  SHLA命令と同様です．

\item[ニーモニック：]\texttt{SHLL  GR}
  % \\SHLA命令と同様です．

\item[命令フォーマット：]SHLL命令は1バイトの命令です．
  XRフィールドは必ず $01_2$にします．

  \oneByte{$1001_2$}{\GR~$01_2$}

\item[フローチャート：]SHLL命令は次のように描くことにします．
  SHLA命令と全く同じ動作をするので，
  フローチャートの描き方も，
  SHLA命令と全く同じです．

  \begin{center}
    \myincludegraphics{Tikz/shla.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  A番地のデータを2ビット左にシフトしB番地に格納する例です．
  左に2ビットシフトすることは$\times 4$を計算することと同じです．
  例ではSHLA命令を用いていますが，SHLL命令を用いても全く同じ結果になります．

  {\ttfamily\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 07 &   & LD   & G0,A \\
      02 & 90    &   & SHLA & G0   \\
      03 & 90    &   & SHLA & G0   \\
      04 & 20 08 &   & ST   & G0,B \\
      06 & FF    &   & HALT &      \\
      07 & 01    & A & DC   & 1    \\
      08 & 00    & B & DS   & 1    \\
      \hline
    \end{tabular}
  \end{center}}

\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{SHRA（Shift Right Arithmetic）命令}
右算術（算術＝Arithmetic）シフトと言います．
レジスタのデータを右方向に1ビットずらします．
左側からシフト前のデータの最上位ビット（符号ビット）と同じ値が入力されます．
右にはみ出したビットは，Cフラグの値になります．

\begin{center}
  \myincludegraphics{Tikz/shft2.pdf}{scale=0.8}
\end{center}

\begin{description}
\item[意味：]レジスタの値を右に1ビット\emph{算術シフト}します．

\item[フラグ：]
  SHLA命令と同様です．

\item[ニーモニック：]\texttt{SHRA  GR}
  % \\SHLA命令と同様です．

\item[命令フォーマット：]SHRA命令は1バイトの命令です．
  XRフィールドは必ず $10_2$にします．

  \oneByte{$1001_2$}{\GR~$10_2$}

\item[フローチャート：]SHRA命令は次のように描くことにします．
  %なお，この書き方は，Java言語やC言語のシフト演算子を真似たものです．

  \begin{center}
    \myincludegraphics{Tikz/shra.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  A，B番地のデータを1ビット右にシフトし，C，D番地に格納します．
  右1ビットシフトと，$\div 2$の結果は同じです．
  算術シフトの場合は，負の数でも正しく $1/2$ の値になります．

  {\ttfamily\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 0B &   & LD   & G0,A \\
      02 & 92    &   & SHRA & G0   \\
      03 & 20 0D &   & ST   & G0,C \\
      05 & 14 0C &   & LD   & G1,B \\
      07 & 96    &   & SHRA & G1   \\
      08 & 24 0E &   & ST   & G1,D \\
      0A & FF    &   & HALT &      \\
      0B & 08    & A & DC   & 8    \\
      0C & F8    & B & DC   & -8   \\
      0D & 00    & C & DS   & 1    \\
      0E & 00    & D & DS   & 1    \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{SHRL（Shift Right Logical）命令}
右論理（論理＝Logical）シフトと言います．
レジスタのデータを右方向に1ビットずらします．
左側から``0''が入力されます．
右にはみ出したビットは，Cフラグの値になります．

\begin{center}
  \myincludegraphics{Tikz/shft3.pdf}{scale=0.8}
\end{center}

\begin{description}
\item[意味：]レジスタの値を右に1ビット\emph{論理シフト}します．

\item[フラグ：]
  SHLA命令と同様です．

\item[ニーモニック：]\texttt{SHRL  GR}
  % \\SHLA命令と同様です．

\item[命令フォーマット：]SHRL命令は1バイトの命令です．
  XRフィールドは必ず $11_2$にします．

  \oneByte{$1001_2$}{\GR~$11_2$}

\item[フローチャート：]SHRL命令は次のように描くことにします．
  %なお，この書き方は，Java言語のシフト演算子を真似たものです．

  \begin{center}
    \myincludegraphics{Tikz/shrl.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  A，B番地のデータを1ビット右にシフトし，C，D番地に格納します．
  右1ビットシフトと，$\div 2$は同じ結果になります．
  論理シフトの場合は，128以上の大きな数でも正しく $1/2$ の値になります．

  {\ttfamily\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 0B &   & LD   & G0,A \\
      02 & 93    &   & SHRL & G0   \\
      03 & 20 0D &   & ST   & G0,C \\
      05 & 14 0C &   & LD   & G1,B \\
      07 & 97    &   & SHRL & G1   \\
      08 & 24 0E &   & ST   & G1,D \\
      0A & FF    &   & HALT &      \\
      0B & 7F    & A & DC   & 127  \\
      0C & 80    & B & DC   & 128  \\
      0D & 00    & C & DS   & 1    \\
      0E & 00    & D & DS   & 1    \\
      \hline
    \end{tabular}
  \end{center}}
\end{description}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{シフトの動作確認}{5_4}
  \begin{description}
  \item[問題：] 4種類のシフト命令について，
    G0レジスタの値をシフトしながら動作を確認しなさい．

  \item[プログラム：]
    次のプログラムを作成します．

    \begin{center}
      {\ttfamily\small
        \begin{tabular}{|c|l|l|l l|} \hline
          番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
          \hline
          00 & 90    & L0  & SHLA & G0     \\
          01 & FF    &     & HALT &        \\
          02 & A0 00 &     & JMP  & L0     \\
          \hline
        \end{tabular}
      }
    \end{center}

  \item[フローチャート：] フローチャートで描く場合は，
    次のように HALT を表現することにします．

    \begin{center}
      \myincludegraphics{Tikz/flow4A.pdf}{scale=0.8}
    \end{center}


  \item[実行方法：] 次の手順で実行します．
    \begin{enumerate}
    \item PCを$00_{16}$にする．
    \item G0レジスタに適当なデータを書き込む．
    \item ロータリースイッチをG0に合わせたまま，RUNボタンを押す．
    \item G0の値がシフトされたことが，データランプで確認できる．
    \item 再度，RUNボタンを押す．
    \item G0の値が更にシフトされる．
    \end{enumerate}

    \vspace{1ex}
    一度RUNボタンを押すとHALT命令で停止します．
    そのとき，PCはJMP命令を指していますので，
    再度RUNボタンを押すと，
    もう一度，最初からプログラムが実行されます．

    \vspace{1ex}
    SHLA命令の動作が良く分かったら別のシフト命令でも試してみましょう．

  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{ビットの回転}{5_5}
  \begin{description}
  \item[問題：] 次の図のように，
    G0レジスタの値を1ビット左回転するプログラムを作りなさい．

    \begin{center}
      \myincludegraphics{Tikz/shft4.pdf}{scale=0.8}
    \end{center}

  \item[考え方：]
    TeCには，ビットを回転する命令がありません．
    次の手順で目的を達成します．
    \begin{enumerate}
    \item シフト命令でG0を1ビットシフトする．
    \item はみ出したビットがCフラグに保存されているので，
      Cフラグを調べる．
    \item Cフラグが1だった場合は，G0の最下位ビットを1にする．
    \end{enumerate}

    \begin{center}
      \myincludegraphics{Tikz/flow4.pdf}{scale=0.8}
    \end{center}

  \item[プログラム：]
    プログラムにすると次のようになります．
    \reidairef{5_4}と同様に最後にJMP命令を追加しました．

    {\ttfamily\small\begin{center}
      \begin{tabular}{|c|l|l|l l|} \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        00 & 91    & L0  & SHLL & G0     \\
        01 & A8 05 &     & JC   & L1     \\
        03 & A0 07 &     & JMP  & L2     \\
        05 & 30 0A & L1  & ADD  & G0,ONE \\
        07 & FF    & L2  & HALT &        \\
        08 & A0 00 &     & JMP  & L0     \\
        0A & 01    & ONE & DC   & 1      \\
        \hline
      \end{tabular}
    \end{center}}

  \item[実行方法：] \reidairef{5_4}と同様です．
    実行する度に，データランプの表示が回転します．
  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{シフトを用いた高速乗算}{5_6}
  \begin{description}
  \item[問題：] シフトを用いて，
    Aの10倍の値をBに求めるプログラムを作りなさい．

  \item[考え方：]
    TeCには，かけ算命令がありません．
    そのため，繰り返しでかけ算をする方法を，以前，紹介しました．
    ここでは，繰り返しによる方法より高速なかけ算を紹介します．

    $\times 10$は，次の式のように変形できます．

    \begin{center}
      $B = A \times 10 = A \times 8 + A \times 2$
    \end{center}

    $\times 2$は，1ビット左にシフトすることと同じです．
    $\times 8$は，3ビット左にシフトすることと同じです．
    シフトした結果同士を足し合わせることにより，10倍を計算することができます．

  \item[プログラム：]
    プログラムにすると次のようになります．
    TMPは，一時的にAの2倍の値を記憶するために使用します．

    {\ttfamily\small\begin{center}
      \begin{tabular}{|c|l|l|l l|} \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        00 & 10 0C &     & LD   & G0,A   \\
        02 & 90    &     & SHLA & G0     \\
        03 & 20 0E &     & ST   & G0,TMP \\
        05 & 90    &     & SHLA & G0     \\
        06 & 90    &     & SHLA & G0     \\
        07 & 30 0E &     & ADD  & G0,TMP \\
        09 & 20 0D &     & ST   & G0,B   \\
        0B & FF    &     & HALT &        \\
        0C & 03    & A   & DC   & 3      \\
        0D & 00    & B   & DS   & 1      \\
        0E & 00    & TMP & DS   & 1      \\
        \hline
      \end{tabular}
    \end{center}}

  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item Aの値の7倍をBに求めるプログラムを作りなさい．
\item Aの値が符号無し2進数の場合，
  Aの値の $1/4$ 倍をBに求めるプログラムを作りなさい．
\item Aの値が符号無し2進数の場合，
  Aの値の $1.5$ 倍をBに求めるプログラムを作りなさい．
\end{enumerate}
\vfill

%=============================================================================
\newpage
\section{論理演算命令}
\emph{\ref{logical} 論理演算と論理回路}で学んだ論理演算を行う機械語命令です．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{AND（Logical AND）命令}
AND命令は，
レジスタとメモリデータのビット毎の論理積（AND）を計算します．
ビット毎の論理積とは，次の図のように，
レジスタとメモリの対応するビット同士の論理積の計算のことです．
計算結果はレジスタに格納されます．

\begin{center}
  \myincludegraphics{Tikz/land.pdf}{scale=0.7}
\end{center}

\begin{description}
\item[意味：]ビット毎の論理積を計算します．
  結果は元のレジスタに格納します．（メモリの値は変化しません．）

\item[フラグ：]Cフラグは常に0になります．
  S，Zフラグは計算の結果により変化します．

\item[ニーモニック：]\texttt{AND  GR,EA} \\
  \texttt{GR}は，計算の対象になるレジスタを表します．
  このレジスタの値と\texttt{EA}で表されるメモリの値の
  ビット毎の論理積が計算されます．
  結果はこのレジスタに格納されます．

\item[命令フォーマット：]AND命令は2バイトの長さを持ちます．
  各フィールドの意味は，LD命令と同様です．

  \twoByte{$0110_2$}{\GR~\XR}{\A}

\item[フローチャート：]AND命令は次のように描くことにします．
  これも，Java言語やC言語の演算子を真似したものです．

  \begin{center}
    \myincludegraphics{Tikz/and_chap5.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  A番地のデータとB番地のデータのビット毎の論理積を計算し，
  C番地に格納するプログラムの例を示します．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      00 & 10 07 &   & LD   & G0,A \\
      02 & 60 08 &   & AND  & G0,B \\
      04 & 20 09 &   & ST   & G0,C \\
      06 & FF    &   & HALT &      \\
      07 & 63    & A & DC   & 63H  \\
      08 & 0F    & B & DC   & 0FH  \\
      09 & 00    & C & DS   & 1    \\
      \hline
    \end{tabular}
  \end{center}}


  \begin{center}
    \myincludegraphics{Tikz/land1.pdf}{scale=0.7}
  \end{center}

\end{description}

\subsubsection{AND命令の応用}
AND命令は，データの特定のビットを0にクリアしたり，
データの特定のビットの 1/0 を確かめたり，
データの一部のビットだけを取り出したりするために使用できます．

\begin{enumerate}
\item 特定の1ビットがゼロかそうでないか判定できます．
  次はG0の最下位ビット（LSB）がゼロならジャンプする例です．
  $01_{16}$とのANDの結果が$00_{16}$になることから，
  LSBが$0$だったことが分かります．

  {\small\ttfamily\begin{center}
    \begin{tabular}{|l|l l|l}
      \cline{1-3}
      ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
      \cline{1-3}
      & ...  &        & \\
      & AND  & G0,ONE & \\
      & JZ   & L1     & \\
      & ...  &        & \\
      L1  & ...  &        & \\
      & ...  &        & \\
      ONE & DC   & 01H    & \\
      \cline{1-3}
    \end{tabular}
  \end{center}}

\item バイト中の連続した数ビットを取り出すことができます．
  次はG0の，$b_3$，$b_2$の2ビットだけを右詰めにして取り出す例です．
  下の図のように，まずAND命令で目的の2ビット以外を0にします．
  次に右に2回シフトして右詰めにします．

  {\small\ttfamily\begin{center}
    \begin{tabular}{|l|l l|l}
      \cline{1-3}
      ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
      \cline{1-3}
      & ...  &        & \\
      & AND  & G0,MSK & \\
      & SHRL & G0     & \\
      & SHRL & G0     & \\
      & ...  &        & \\
      MSK & DC   & 0CH    & \\
      \cline{1-3}
    \end{tabular}
  \end{center}}

  \begin{center}
    \myincludegraphics{Tikz/land2.pdf}{scale=0.7}
  \end{center}

\item $2^n$の倍数になるように切り捨てることができます．
  次はG0の値を$2^3=8$の倍数になるように切り捨てる例です．
  下3ビットをゼロにすると8の倍数になります．

  {\small\ttfamily\begin{center}
    \begin{tabular}{|l|l l|l}
      \cline{1-3}
      ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
      \cline{1-3}
      & ...  &        & \\
      & AND  & G0,MSK & \\
      & ...  &        & \\
      MSK & DC   & 0F8H   & \\
      \cline{1-3}
    \end{tabular}
  \end{center}}

\item $2^n$で割った余りを求めることができます．
  次はG0の値を$2^3=8$で割った余りを求める例です．
  下3ビットだけを取り出すと8で割った余りになります．

  \begin{center}
    {\small\ttfamily
      \begin{tabular}{|l|l l|l}
        \cline{1-3}
        ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
        \cline{1-3}
        & ...  &        & \\
        & AND  & G0,MSK & \\
        & ...  &        & \\
        MSK & DC   & 07H    & \\
        \cline{1-3}
      \end{tabular}
    }
  \end{center}

  \vspace{1ex}
  このように，2の累乗（2,4,8,16,...）で割った商や余りは，
  シフトや論理演算で簡単に計算できます．
  また，2の累乗の倍数に切捨てたり，
  切り上げたりする計算も，
  論理演算を使うと簡単にできます．

\end{enumerate}

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{16進数の表記}
      ニーモニック中で数値を16進数で書き表したいことがあります．
      そのときは，前のプログラム中のDC命令のように，数値の後ろに``H''を付けます．

      16進数が``A''〜``F''で始まると数値なのかラベルなのか分かりません．
      このような場合は数値であることが分かるように先頭に``0''を付加します．
      例えば\texttt{F8H}は\texttt{0F8H}と書きます．
  }\end{framed}
\end{figure}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{OR（Logical OR）命令}
OR命令は，
レジスタとメモリデータの対応するビット同士の論理和（OR）を計算します．
%AND命令の論理和版です．
計算結果はレジスタに格納されます．

\begin{description}
\item[意味：]ビット毎の論理和を計算します．
  結果は元のレジスタに格納します．（メモリの値は変化しません．）

\item[フラグ：]Cフラグは常に0になります．
  S，Zフラグは計算の結果により変化します．

\item[ニーモニック：]\texttt{OR  GR,EA} \\
  \texttt{GR}は，計算の対象になるレジスタを表します．
  このレジスタの値と\texttt{EA}で表されるメモリの値の
  ビット毎の論理和が計算されます．
  結果はこのレジスタに格納されます．

\item[命令フォーマット：]OR命令は2バイトの長さを持ちます．
  各フィールドの意味は，LD命令と同様です．

  \twoByte{$0111_2$}{\GR~\XR}{\A}

\item[フローチャート：]OR命令は次のように描くことにします．
  これも，Java言語やC言語の演算子を真似したものです．

  \begin{center}
    \myincludegraphics{Tikz/or_chap5.pdf}{scale=0.8}
  \end{center}

\end{description}

\subsubsection{OR命令の応用}
OR命令は，データの特定のビットを1にするために使用できます．
次の例は，G0の上位4ビットを全て1にします．

{\ttfamily\small\begin{center}
  \begin{tabular}{|l|l l|l}
    \cline{1-3}
    ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
    \cline{1-3}
    & ...  &        & \\
    & LD   & G0,DATA& \\
    & OR   & G0,MSK & \\
    & ...  &        & \\
    DATA& DC   & 0AAH    & \\
    MSK & DC   & 0F0H    & \\
    \cline{1-3}
  \end{tabular}
\end{center}}

\begin{center}
  \myincludegraphics{Tikz/lor.pdf}{scale=0.7}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{XOR（Logical XOR）命令}
XOR命令は，
レジスタとメモリデータの対応するビット同士の排他的論理和（XOR）を計算します．
計算結果はレジスタに格納されます．

\begin{description}
\item[意味：]ビット毎の排他的論理和を計算します．
  結果は元のレジスタに格納します．（メモリの値は変化しません．）

\item[フラグ：]Cフラグは常に0になります．
  S，Zフラグは計算の結果により変化します．

\item[ニーモニック：]\texttt{XOR  GR,EA} \\
  \texttt{GR}は，計算の対象になるレジスタを表します．
  このレジスタの値と\texttt{EA}で表されるメモリの値の
  ビット毎の排他的論理和が計算されます．
  結果はこのレジスタに格納されます．

\item[命令フォーマット：]XOR命令は2バイトの長さを持ちます．
  各フィールドの意味はLD命令と同様です．

  \twoByte{$1000_2$}{\GR~\XR}{\A}

\item[フローチャート：]XOR命令は次のように描きます．
  %これも，Java言語やC言語の演算子を真似したものです．

  \begin{center}
    \myincludegraphics{Tikz/xor_chap5.pdf}{scale=0.8}
  \end{center}

\end{description}

\subsubsection{XOR命令の応用}
XOR命令を使用してデータの特定ビットの0/1を反転できます．
TeCにはNOT命令がないのでXOR命令で代用します．
次はG0の上位4ビットの0/1を反転します．

{\ttfamily\small\begin{center}
  \begin{tabular}{|l|l l|l}
    \cline{1-3}
    ラベル & \multicolumn{2}{|c|}{ニーモニック} & \\
    \cline{1-3}
    & ...  &        & \\
    & LD   & G0,DATA& \\
    & XOR  & G0,MSK & \\
    & ...  &        & \\
    DATA& DC   & 0AAH    & \\
    MSK & DC   & 0F0H    & \\
    \cline{1-3}
  \end{tabular}
\end{center}}

\begin{center}
  \myincludegraphics{Tikz/lxor.pdf}{scale=0.7}
\end{center}

%=============================================================================
\newpage
\section{アドレッシングモード}
LD，ST，ADD，SUB，CMP，AND，OR，XOR，
JMP，JZ，JC，JM，JNZ，JNC，JNM命令は，
どれも次のような同じ命令フォーマットでした．
これまで，これらの命令の $XR$ 部分は $00_2$ にしてきました．

\twoByte{\OP}{\GR~\XR}{\A}

$XR$に$00_2$以外を指定することにより，
メモリアドレス（実効アドレス）表現方法を変更することができます．
実効アドレスの表現方法のことをアドレッシングモードと呼びます．
TeCで使用できるアドレッシングモードは，
$XR$の値により\tabref{chap5:xr}に示す4種類があります．

\begin{mytable}{btp}{XRフィールドの値とアドレシングモード}{chap5:xr}
  {\small\begin{center}
    \begin{tabular}{c|l l}
      \hline
      \hline
      XR & \multicolumn{2}{|c}{意味} \\
      \hline
      $00_2$ & ダイレクトモード     & （直接モード）   \\
      $01_2$ & G1インデクスドモード & （G1指標モード） \\
      $10_2$ & G2インデクスドモード & （G2指標モード） \\
      $11_2$ & イミディエイトモード & （即値モード）   \\
    \end{tabular}
  \end{center}}
\end{mytable}

（同様な表が「\figref{appC:insttbl} TeC7命令表」にも掲載されているので，
  そちらも確認してください．）

以下ではLD命令とST命令を例に，
4種類のアドレッシングモードを説明します．
ここでは説明しませんが，
ADD， SUB， CMP， AND， OR， XOR命令でも，
LD命令やST命令と同様にアドレッシングモードが使用できます．

%----------------------------------------------------------------------------
\begin{figure}[btp]
  \begin{framed}{\parindent=1em
      \subsection*{実効アドレス}
      \emph{実効アドレス（Effective Address）}は，
      命令が操作対象にするメモリのアドレス（番地）のことです．
      Effective Address を EA と略して書くこともあります．
      これまで，命令のニーモニック，フローチャート，命令表の動作説明欄等に，
      \texttt{EA}とか\texttt{[EA]}の記述が出てきました．
      これらは，実効アドレスや，実効アドレスに置いてあるデータを指していました．

      \texttt{EA}の意味や，ニーモニックやフローチャートでの表記方法は，
      アドレッシングモードにより変化します．
      例えばG1インデクスドモードの時，
      \texttt{EA} は
      「命令のアドレス部（第２バイト）の値とG1レジスタの値を加えた値の番地」を意味し，
      ニーモニックでは\texttt{EA} を \texttt{A,G1} のように表記しますし，
      フローチャートでは\texttt{[EA]} を \texttt{[A+G1]} のように表記します．
  }\end{framed}
\end{figure}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{ダイレクト（直接）モード}
これまで使用してきたのは，このモードです．
命令の第2バイトがメモリアドレスを直接に表します．

ニーモニックでは次のように書きました．
ここで，A，Bは，データを置いたメモリのアドレスです．

{\ttfamily\begin{center}
  \begin{tabular}{l l}
    LD & G0,A \\
    ST & G0,B \\
  \end{tabular}
\end{center}}

フローチャートでは，次のように描きました．

\begin{center}
  \myincludegraphics{Tikz/flowE.pdf}{scale=0.8}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{インデクスド（指標）モード}
G1またはG2レジスタの値と，
命令の第2バイトの値の合計がメモリアドレスを表します．
$XR$の値により，G1，G2どちらのレジスタを使用するか決まります．
G0レジスタは使用できないので注意してください．

このモードは，配列データをアクセスするとき使用できます．
また，ジャンプ命令でも使用できます．
ジャンプ命令でインデクスドモードを使用する方法は，
%本書では扱いません．
「\ref{jmptbl} ジャンプテーブル」で説明します．

ニーモニックでは次のように書きます．
このプログラムは，
$A+G1$番地のデータをG0に読込み，
$B+G2$番地に格納しています．

{\ttfamily\begin{center}
  \begin{tabular}{l l}
    LD & G0,A,G1 \\
    ST & G0,B,G2 \\
  \end{tabular}
\end{center}}

フローチャートでは，次のように描きます．

\begin{center}
  \myincludegraphics{Tikz/flowF.pdf}{scale=0.8}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{イミディエイト（即値）モード}
第2バイトがデータそのものになるモードです．
ST命令やジャンプ命令では使用できません．
（これらの命令で$XR$を$11$にすると，
  CPUが命令を実行しようとしたとき，
  命令コードのエラーになりRUNランプが点滅します．）

ニーモニックでは次のように書きます．
{\ttfamily\begin{center}
  \begin{tabular}{l l}
    LD & G0,\#1       \\
    LD & G1,\#A       \\
  \end{tabular}
\end{center}}

最初のLD命令は，G0を1にします．
次のLD命令は，G1をAの番地（内容ではない）にします．
フローチャートでは，次のように描きます．

\begin{center}
  \myincludegraphics{Tikz/flowG.pdf}{scale=0.8}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{アドレッシングモードの使用例}
A番地のデータで，
B番地からの10バイトの配列を初期化するプログラムの例を示します．

G1，G2レジスタの初期化と
G1，G2レジスタの値を±1する部分にイミディエイトモードを使用しました．

また，10回の繰り返しで10バイトの領域を初期化できるよう，
ST命令の格納アドレスがG2の値で1番地ずつずれていきます．
ずらすためにインデクスドモードを使用しました．

{\small\ttfamily\begin{center}
  \begin{tabular}{|l|l|l|l l|} \hline
    番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
    \hline
    00 & 10 11 &      & LD   & G0,A          \\
    02 & 17 0A &      & LD   & G1,\#10       \\
    04 & 1B 00 &      & LD   & G2,\#0        \\
    06 & 22 12 & LOOP & ST   & G0,B,G2       \\
    08 & 3B 01 &      & ADD  & G2,\#1        \\
    0A & 47 01 &      & SUB  & G1,\#1        \\
    0C & A4 10 &      & JZ   & STOP          \\
    0E & A0 06 &      & JMP  & LOOP          \\
    10 & FF    & STOP & HALT &               \\
    11 & AA    & A    & DC   & 0AAH          \\
    12 & 00 00 00 00 00 & B    & DS   & 10            \\
    17 & 00 00 00 00 00 &      &      &               \\
    \hline
  \end{tabular}
\end{center}}

次に，このプログラムのフローチャートを示します．
イミディエイトモードとインデクスドモードを，
フローチャート上でどのように表現しているか，
よく確認してください．

\begin{center}
  \myincludegraphics{Tikz/flowD.pdf}{scale=0.8}
\end{center}

%----------------------------------------------------------------------------
\subsubsection{問題}
\begin{enumerate}
\item これまでに出てきたプログラムを
  イミディエイトモードを使用して書き換えなさい．
\item A番地からの5バイトのデータの合計を
  B番地に求めるプログラムを作りなさい．
\item A番地からの5バイトのデータを
  B番地からの5バイトにコピーするプログラムを作りなさい．
\item A番地からの5バイトのデータのビットを反転するプログラムを作りなさい．
\item A番地からの5バイトとB番地からの5バイトの
  ビット毎の論理和をC番地からの5バイトに求める
  プログラムを作りなさい．
\item A番地からの5バイトのデータのなかで，奇数の個数をB番地に求める
  プログラムを作りなさい．\\
  （ヒント：奇数のLSBは必ず1になっている．）
\item A番地からの5バイトのデータの最大の値をB番地に求める
  プログラムを作りなさい．
\item A番地からの5バイトのデータの合計をB番地に求めるプログラムを
  インデクスドモードを使用しないで作りなさい．\\
  （ヒント：プログラムが自身を書き換えながら動作する．）
\end{enumerate}

%=============================================================================
\newpage
\section{入出力}
\emph{\figref{chap5:kousei2} TeCの構成}に示した主記憶装置（メモリ）は，
LD，ST命令等を使用することでアクセスできることが分かりました．
ここで説明する入出力（Input Output=略して I/O）命令は，
入出力インターフェース回路をアクセスするための命令です．
読み込みを行うIN命令，書き込みを行うOUT命令の2種類があります．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{I/Oマップ}
\label{iomap}

いくつか存在するインターフェース回路の中で，
どれをアクセスするかはI/Oアドレス（メモリアドレスとは別のもの）に
より指定します．
TeCのI/Oアドレスは$0_{16}$〜$F_{16}$までの16番地です．
I/Oアドレスの一覧を「I/Oマップ」と言います．
TeCの「I/Oマップ」を\tabref{chap5:iomap}に示します．
%I/Oマップを通して見たインターフェース回路のことを，
%「I/Oポート」と呼びます．

\begin{mytable}{btp}{I/Oマップ}{chap5:iomap}
  \small\begin{tabular}{| l | l | l |}
  \hline
  \multicolumn{3}{|c|}{I/Oマップ} \\
  \hline
  番地 & \multicolumn{1}{|c|}{Read} & \multicolumn{1}{|c|}{Write} \\
  \hline
  0 & データスイッチ   & ブザー \\
  1 & データスイッチ   & スピーカ \\
  2 & SIO受信データ    & SIO送信データ \\
  3 & SIOステータス    & SIOコントロール \\
  4 & タイマ現在値     & タイマ周期 \\
  5 & タイマステータス & タイマコントロール \\
  6 & 空き             & INT3コントロール \\
  7 & PIO入力ポート    & PIO出力ポート \\
  8 & ADC CH0          & 空き \\
  9 & ADC CH1          & 空き \\
  A & ADC CH2          & 空き \\
  B & ADC CH3          & 空き \\
  C & 空き             & PIOコントロール \\
  D & 空き             & 空き \\
  E & 空き             & 空き \\
  F & 空き             & 空き \\
  \hline
  \end{tabular}
\end{mytable}

「\tabref{chap5:iomap} I/Oマップ」から次のことが分かります．
（詳しくは，後の方で説明します．）

\begin{enumerate}
\item 0番地のRead（読み込み）により，データスイッチの値を読み込むことができる．
\item 0番地のWrite（書き込み）により，ブザーにアクセスできる．
\item 1番地のRead（読み込み）でも，データスイッチの値を読み込むことができる．
\item 1番地のWrite（書き込み）により，スピーカーにアクセスできる．
\item 2，3番地は，SIO（シリアル入出力）を
  用いてパソコンと通信するために使用される．
\item 4，5番地は，タイマを使用して時間を計るために使用される．
\item 6番地は，コンソールパネルから発生するINT3割込を制御する．
\item 7番地は，入出力ポートの値を読み書きするために使用される．
\item 8，9，A，B番地はADC（A/Dコンバータ：電圧を計測して数値に変換する回路）の
  値を読み取るために使用される．
\item C，D，E，F番地は使用されない．
\end{enumerate}

I/Oマップは「\figref{appC:insttbl} TeC7命令表」
にも掲載されているので確認してください．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{IN（Input）命令}
入出力インターフェース回路からデータを入力します．

\begin{description}
\item[意味：]4ビットのI/Oアドレスで指定した
  入出力インタフェース回路からデータをレジスタに入力します．

\item[ニーモニック：]\texttt{IN  GR,P} \\
  \texttt{GR}は値を入力するレジスタを表します．
  \texttt{P}は入出力インターフェース回路のI/Oアドレスです．

\item[命令フォーマット：]IN命令は2バイトの長さを持ちます．
  XRフィールドは必ず$00_2$にします．
  第2バイトの上位4ビットも必ず$0000_2$にします．

  \twoByte{$1100_2$}{\GR~$00_2$}{\PP}

\item[フローチャート：]IN命令は次のように描くことにします．
  「動作の説明」は各自が工夫して下さい．

  \begin{center}
    \myincludegraphics{Tikz/in.pdf}{scale=0.8}
  \end{center}

\item[使用例：]
  次のプログラムはデータスイッチの状態をI/Oアドレス0番地から読み取り，
  G0レジスタに格納するものです．
  ロータリースイッチをG0に合わせた状態で，
  プログラムを実行してください．
  データスイッチを変化させると即座にデータランプの表示が変化します．

  プログラムは無限ループになっているので，
  実行を開始したらSTOPボタンを押すまで止まりません．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l l|l}
      \cline{1-3}
      ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      START & IN   & G0,0    \\
      & JMP  & START   \\ 
      \hline
    \end{tabular}
  \end{center}}

\end{description}

\subsubsection{IN命令の応用}
次のプログラムは，
データスイッチから数値を入力し，
合計をG0に求めるものです．
ロタリースイッチをG0に合わせて実行すると，
2進数入力，2進数表示の簡単な電卓として使用できます．

操作手順は次の通りです．

\begin{enumerate}
\item プログラムを入力する．
\item PCにプログラムの実行開始番地をセットする．
\item ロータリースイッチをG0に合わせる．
\item データスイッチにデータをセットする．
\item RUNボタンを押す．
\item データの件数分，4，5を繰り返す．
\item データランプに合計が表示されている．
\end{enumerate}

{\ttfamily\small\begin{center}
  \begin{tabular}{|l|l l|l}
    \cline{1-3}
    ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
    \hline
    START & LD   & G0,\#0        \\
    LOOP  & IN   & G1,00H        \\
    & ST   & G1,TMP        \\
    & ADD  & G0,TMP        \\
    & HALT &               \\
    & JMP  & LOOP          \\ 
    \hline
  \end{tabular}
\end{center}}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item データスイッチから0で終了する値を次々入力し，
  合計をX番地に求めるプログラムを作りなさい．
\item A番地からの5バイトを，
  実行開始時にデータスイッチにセットしてあった値で埋めつくす
  プログラムを作りなさい．
\end{enumerate}
\vfill

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{OUT（Output）命令}
\label{out}

入出力インターフェース回路へデータを出力します．

\begin{description}
\item[意味：]レジスタのデータを
  4ビットのI/Oアドレスで指定した入出力インタフェース回路へ出力します．

\item[ニーモニック：]\texttt{OUT  GR,P} \\
  \texttt{GR}は出力する値を持っているレジスタを表します．
  \texttt{P}は入出力インターフェース回路のアドレスです．

\item[命令フォーマット：]OUT命令は2バイトの長さを持ちます．
  XRフィールドは必ず$11_2$にします．
  第2バイトの上位4ビットも必ず$0000_2$にします．

  \twoByte{$1100_2$}{\GR~$11_2$}{\PP}

\item[使用例：]
  次のプログラムはデータスイッチの値を読み取り，
  ブザー用のポートに出力するものです．

  ブザーは\figref{chap5:buzzer}のような構造になっており，
  I/Oアドレス0番地に書き込んだ値で鳴ったり止まったりします．
  プログラム実行中にデータスイッチを操作して，
  最下位ビットを1にするとブザーが鳴ります．
  逆に最下位ビットを0にするとブザーの音が止まります．

  プログラムは無限ループになっているので，
  実行を開始したらSTOPボタンを押すまで止まりません．
  ブザーが鳴っている状態でプログラムを停止しても，
  ブザーが鳴りっぱなしになります．
  その場合は，RESETスイッチを押して下さい．

  {\ttfamily\small\begin{center}
    \begin{tabular}{|l|l l|l}
      \cline{1-3}
      ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      START & IN   & G0,00H  \\
      & OUT  & G0,00H  \\
      & JMP  & START   \\ 
      \hline
    \end{tabular}
  \end{center}}

  \myfigureN{tbp}{scale=0.9}{chap5/buz1.pdf}{ブザーの仕組み}{chap5:buzzer}

\end{description}

%----------------------------------------------------------------------------
\subsubsection{問題}
\begin{enumerate}
\item データスイッチのビット7(D7)をオンにしている間，
  ブザーを鳴らすプログラムを作りなさい．\\
  （但し，論理演算命令を用いること．）
\item データスイッチのビット7(D7)をオンにしている間，
  ブザーを鳴らすプログラムを作りなさい．\\
  （但し，シフト命令を用いること．）
\item データスイッチのビット0(D0)をオンにしている間，
  ブザーを鳴らすプログラムを作りなさい．\\
  （但し，データスイッチの7(D7)がオンになったら，
    ブザーを止めて終了するようにすること．）
\end{enumerate}
\vfill

%----------------------------------------------------------------------------
%\begin{figure}[btp]
\begin{framed}{\parindent=1em
  \subsection*{定数の定義（EQU命令）}
  {\small IN命令の使用例では
    データスイッチの値を読み込むためのI/Oアドレス 00H が
    プログラム中に直接書いてありました．
    データスイッチのことだと分かりやすい
    名前を用いるとプログラムが読みやすくなります．
    EQU命令は，名前（ラベル）を定義するための命令です．
    EQU命令のオペランドの値をラベルに割り付けます．
    他の命令と異なり，機械語やデータを生成しません．
    
    {\ttfamily\small\begin{center}
      \begin{tabular}{|c|l|l|l l|l}
        \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        00 &       & DSW   & EQU  & 00H     \\
        00 & C0 00 & START & IN   & G0,DSW  \\
        02 & A0 00 &       & JMP  & START   \\ 
        \hline
      \end{tabular}
  \end{center}}}
}\end{framed}
%\end{figure}

%----------------------------------------------------------------------------
%\begin{figure}[btp]
\begin{framed}{\parindent=1em
  \subsection*{TeCパラレル入出力（PIO）の拡張機能}
  {\small 標準では入力8ビット・出力8ビットの構成ですが，
    入力4ビット・出力12ビットの構成に切り替えることができます．
    I/Oアドレス 0CH 番地の $b_7$ に 1 を書き込むと
    入出力ポートコネクタの $I_7〜I_4$ 4ビットが出力に切り替わります．
    この時，書き込んだデータの $b_3〜b_0$ が $I_7〜I_4$ に出力されます．
    
    次のプログラムは，
    入出力ポートコネクタの $I_7〜I_4$ に $1010_2$ を出力します．

    {\ttfamily\small\begin{center}
      \begin{tabular}{|c|l|l|l l|l}
        \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        0C &       & PIOEX & EQU  & 0CH      \\
        00 & 13 8A & START & LD   & G0,\#8AH \\
        02 & C3 0C &       & OUT  & G0,PIOEX \\ 
        04 & FF    &       & HALT &          \\
        \hline
      \end{tabular}
  \end{center}}}
}\end{framed}
%\end{figure}

%----------------------------------------------------------------------------
\newpage
\section{TeCパラレル入出力（PIO）}
\label{pio}

TeCには「\figref{chap4:kakubu} 各部の名称」の「入出力ポートコネクタ」を通し
8ビットのデータを並列に入力・出力するパラレル入出力
（Parallel Input Output : 略して\emph{PIO}）機能があります．
%（TeC6にはありません．）

%\figref{chap5:ltika}
次の写真はPIOを使用し，
ブレッドボード上のLEDをプログラムで点灯・消灯できるようにした例です．

\begin{center}
  \myincludegraphics{Img/expand.jpg}{width=0.85\columnwidth}
\end{center}

下に入出力ポートコネクタのピン配置図を示します．
I/Oアドレスの7番地にOUT命令で書込んだ2進数データがコネクタの$O_7$〜$O_0$に
出力されます．（対応するビットの``1''が3.3V，``0''が0Vになります．）
I/Oアドレスの7番地をIN命令で読むとコネクタの$I_7$〜$I_0$に入力された
電圧に対応したデータを入力できます．

入出力ポートコネクタの``0V''ピンはTeCのGNDに接続されています．
``3V''ピンはTeCの3.3V電源に接続されています．
外部に接続した回路の電源として使用することができます．

\begin{center}
  \myincludegraphics{chap5/pio.pdf}{scale=1.0}
\end{center}

上の写真では，ブレッドボードを用いて次図のように配線してあります．
ポートに``0''を出力するとLEDが光ります．

\begin{center}
  \myincludegraphics{chap5/haisen.pdf}{scale=1.0}
\end{center}

%----------------------------------------------------------------------------
\newpage
\section{TeCアナログ入力（AIN）}
\label{ain}

TeCには，基板上の入出力ポートコネクタ（\figref{chap4:kakubu}参照）を通して
アナログ電圧値を入力できる機能（Analog INput : 略して \emph{AIN}）があります．

TeCのAINには，同時に4つのアナログ電圧が入力できます．
アナログ電圧は入出力ポートコネクタの
$I_3$，$I_2$，$I_1$，$I_0$ピンから入力します．
入力電圧は，0V〜3.3Vを256等分した数値（0V=0，3.3V=255）に変換されます．
数値に変換された結果は，I/Oアドレス8H〜BHで読み取ることができます．
次の表に，入力ピンとI/Oアドレスの対応をまとめます．

{\footnotesize\begin{center}
  \begin{tabular}{c|l|l}
    \hline
    \hline
    I/O番地 & \multicolumn{1}{|c|}{名称} & \multicolumn{1}{|c}{入力ピン} \\
    \hline
    $8_{16}$ & ADC CH0  & $I_0$ \\
    $9_{16}$ & ADC CH1  & $I_1$ \\
    $A_{16}$ & ADC CH2  & $I_2$ \\
    $B_{16}$ & ADC CH3  & $I_3$ \\
  \end{tabular}
\end{center}}

入出力ポートコネクタの$I_3$，$I_2$，$I_1$，$I_0$ピンは，
パラレル入力にもアナログ入力にも使用されます．
パラレル入力ポートから見ると，
入力電圧が1.6V付近を境界に``0''と``1''が切り替わります．

次にアナログ電圧を入力する配線例を示します．
可変抵抗器を変化させると入力値が変化します．
入力値をプログラムが読み取るためには，
I/Oアドレスの8H番地（ADC CH0）をIN命令で読みます．

\begin{center}
  \myincludegraphics{chap5/haisen1.pdf}{scale=1.0}
\end{center}

%----------------------------------------------------------------------------
%\begin{figure}[btp]
\begin{framed}{\parindent=1em
  \subsection*{Bluetoothによるパソコンとの接続}
  {\small TeC7c 以降の機種では，
    USBだけでなくBluetoothによるシリアル通信が可能です．
    この機能を使用するにはパソコン等に以下のアプリを
    インストールする必要があります．

    \begin{itemize}
    \item macOS用のBluetoothTerminal\label{BluetoothTerminal} \\
      \url{https://github.com/tctsigemura/BluetoothTerminal}
    \item iOS用のMLDP-Terminal \\
      \url{https://github.com/tctsigemura/MLDP-Terminal}
    \item Android用のMLDP-Terminal \\
      \url{https://github.com/yokoro13/MLDPTerminal}
    \end{itemize}
  }
}\end{framed}
%\end{figure}

%----------------------------------------------------------------------------
\newpage
\section{TeCシリアル入出力（SIO）}
\label{sio}
TeCには，
パソコンと接続できるシリアル入出力（Serial Input Output : 略して \emph{SIO}）
インターフェースが備えてあります．
前出のIN，OUT命令を使用して，
SIOインターフェースにアクセスします．

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{シリアル入出力}
名前（Serial＝直列）の通り，データを1ビット毎に，順に転送する方式です．
次の図のように，時間による電圧の変化としてデータを表現します．
また，1ビットの時間として$1/9600$秒を用います．
$1/9600$秒で1ビットを送る通信速度を9600bau（ボー）と言います．

\begin{center}
  \myincludegraphics{chap5/serial0.pdf}{scale=0.8}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{パソコンとの接続}
パソコンと接続するときは，TeCの電源コネクタとパソコンのUSBコネクタを接続します．
TeCには「USBシリアル変換IC」としてFTDI社のFT232RLが実装されているので，
パソコンから電源が供給されると同時にシリアル通信も可能になります．
\footnote{パソコンのOSによってはFT232RL用のドライバをインストールする必要があります．
  その場合は，FTDI社のWebページ（\url{http://www.ftdichip.com/}）
  からVCPドライバを入手してパソコンにインストールしてください．}

次の図にシリアル通信をするときのパソコンとTeCの関係を示します．
FT232RLとTeCのSIOインタフェース回路の間がシリアル通信部分になります．
TeCのプログラムはSIOインタフェース回路を操作するだけなので，
その先にFT232RLやUSBケーブルがあることは分かりません．

\begin{center}
  \myincludegraphics{chap5/serial6.pdf}{scale=0.9}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{I/Oポート}
\label{sioport}

SIOのI/Oポートは，2番地，3番地に配置されています
（「\tabref{chap5:iomap} I/Oマップ」参照）．
内容は次の通りです．

\subsubsection{受信データ}
2番地をIN命令で読むと受信データを読み出すことができます．

\subsubsection{送信データ}
2番地にOUT命令で送信データを書き出すことができます．

\subsubsection{ステータス}
3番地をIN命令で読むと次図のようなデータを読み込むことができます．
各ビットの意味も図の通りです．

\begin{center}
  \myincludegraphics{chap5/serial3.pdf}{scale=1.2}
\end{center}

プログラムは次の手順でステータスを調べ，
データの入出力が可能か判断します．
この判断は頻繁に使用するので，
フローチャートを次のように簡単化して描くことにします．

\begin{center}
  \myincludegraphics{chap5/serial5.pdf}{width=0.9\columnwidth}
\end{center}

\subsubsection{コントロール}
3番地へOUT命令で次図のようなデータを書き込みます．
詳細は，「\ref{chap6:ioint} 入出力割込み」で説明します．

\begin{center}
  \myincludegraphics{chap5/serial4.pdf}{scale=1.2}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\newpage
\subsection{シリアル出力プログラム}
シリアル出力を行うプログラムの一般的なフローチャートを次の図に示します．
I/Oアドレス3番地の「Tビット」が``1''になり，
送信可能になるのを待って出力データを2番地に書き込みます．
Tビットが1か0か調べるために，AND命令を使用しています．
これで，%（TeCがパソコンとケーブルで接続してあれば）
2番地に書き込んだデータがパソコンに送信されます．

\begin{center}
  \myincludegraphics{Tikz/flow6.pdf}{width=0.9\columnwidth}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{シリアル入力プログラム}
シリアル入力を行うプログラムの，
一般的なフローチャートを次の図に示します．
受信データが届き，
I/Oアドレス3番地の「Rビット」が``1''になるのを待って，
2番地からデータを読み込みます．
受信したデータはG0に格納されます．

\begin{center}
  \myincludegraphics{Tikz/flow7.pdf}{width=0.9\columnwidth}
\end{center}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{シリアル入出力データ}
TeCがパソコンと通信するときは，
「\ref{char} 文字の表現」で勉強したASCII コードを使用する約束とします．
パソコンのキーボードを叩くと対応する文字の文字コードがTeCに送信され，
TeCが文字コードを送信すると対応する文字がパソコンの画面に表示されます．
パソコンに，
このように動作する\emph{ターミナルエミュレータ}を動かしておく必要があります．

%----------------------------------------------------------------------------
\newpage
\begin{framed}{\parindent=1em
    \subsection*{ターミナルエミュレータ}\label{terminal}{\small
      その昔，ホストコンピュータのディスプレイとキーボードの役目をした
      文字端末（下の写真）をシミュレーションするソフトウェアのことです．
      文字端末は現代のパソコンのような外観ですが，
      ホストコンピュータから受信した文字を表示するディスプレイと，
      ホストコンピュータに送信する文字をタイプするキーボードの機能しかありません．
      UNIXまたはmacOSの「ターミナル」，macOSの「CoolTerm」，
      Windowsの「Tera Term」等がターミナルエミュレータの一種です．

      ここではTeCがホストコンピュータの役割になります．
      キーボードやディスプレイを持たないTeCは，
      シリアル入出力を通して文字端末のキーボードとディスプレイを使用します．
      ターミナルエミュレータを動作させたパソコンはTeCの文字端末として働きます．
      ターミナルエミュレータは
      TeCから受信したデータをASCII文字コード
      （「\ref{char} 文字の表現」参照）とみなし，
      対応する文字を画面に表示します．
      また，キーボードが押されると，
      押された文字のASCII文字コードをTeCへ送信します．

      「CoolTerm」や「Tera Term」は，
      別のコンピュータと通信することを主な目的に作らています．
      一方でUNIXやmacOSの「ターミナル」は，
      ターミナルエミュレータが動作するのと同じパソコンを
      ホストコンピュータと見做します．
      そこで，「ターミナル」はシリアル通信をターミナルエミュレータに中継する
      「screenプログラム」や「tipプログラム」と組合せて使用します．
      BluetoothTerminal（p.\pageref{BluetoothTerminal}）も
      「screenプログラム」と同様に
      「ターミナル」と組合せて使用するプログラムです．

      TeCのSIOを使用するときは，
      TeCとパソコンをケーブルで接続するだけでなく，
      パソコンにターミナルエミュレータ等を起動し，
      パソコンを文字端末として使用できるように準備する必要があります．
      \begin{center}
        \myincludegraphics{Img/724px-Televideo925Terminal.jpeg}
                          {width=0.9\columnwidth}
      \end{center}
      写真：
      \url{http://commons.wikimedia.org/wiki/File:Televideo925Terminal.jpg}
          （パブリックドメイン）
}}\end{framed}

%----------------------------------------------------------------------------
\begin{framed}{\parindent=1em
    \subsection*{ニーモニック中の文字データ表記}

    文字を扱うプログラムを書くとき，文字コードが必要になります．
    そのときは，ニーモニック中に数値の代わりに，
    「\texttt{'A'}」のように書くことができます．
    文字\texttt{A}の文字コード（\texttt{41H}）と言う意味です．
    （文字コードにはASCIIコードを用います．）

    ニーモニック中の\texttt{'A'}は，
    \texttt{41H}または\texttt{65}と書いたのと全く同じ意味になります．

    DC命令では，連続した文字の定義に\texttt{"文字列"}を使用できます．
    下のプログラム中にあるように，
    \texttt{"TeC"}の表記で3バイトのデータが生成されます．

    {\ttfamily\small\begin{center}
      \begin{tabular}{|c|l|l|l l|l}
        \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        00 & 13 41 & START & LD   & G0,\#'A'        \\
        02 & FF    &       & HALT &                 \\ 
        03 & 42 43 &       & DC   & 'B','C'         \\ 
        05 & 45 65 &       & DC   & "TeC"           \\ 
        07 & 43    &       &      &                 \\
        \hline
      \end{tabular}
    \end{center}}
}\end{framed}

%----------------------------------------------------------------------------
\begin{framed}{\parindent=1em
    \subsection*{ターミナルエミュレータ画面の改行}
    CR（復帰文字）は文字カーソルを画面の左端に移動するための制御文字，
    LF（改行文字）は文字カーソルを一行下に移動するための制御文字です．
    CRの文字コードは\texttt{0DH}，LFの文字コードは\texttt{0AH}です．
    文字コードは\figref{chap2:ascii}を確認して下さい．

    ターミナルエミュレータの表示を改行するには，
    通常，CRとLFの2文字をTeCからパソコンへ送ります．
    しかし，筆者のパソコンで試してみると，
    LFだけを送信しても復帰と改行の両方ができてしまいました．
    （CRを送っても害はありませんでした．）

    ターミナルエミュレータにより，
    必要な制御文字の組合せが異なるようです．
    自分が使用するシステムに合わせて，
    臨機応変に対応してください．
}\end{framed}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{文字列出力1}{5_7}
  \begin{description}
  \item[問題：] SIOへローマ字で自分の名前を出力するプログラムを作りなさい．

  \item[考え方：]
    筆者の場合，\texttt{SHIGEMURA}の9文字を出力するプログラムを作成します．
    データとして準備した9文字を，
    インデクスドモードのアドレッシングを使用し順に出力します．

  \item[フローチャート：]
    次のようになります．

    \begin{center}
      \myincludegraphics{Tikz/flow8.pdf}{scale=0.7}
    \end{center}

  \item[プログラム：]
  \end{description}

  {\ttfamily\footnotesize\begin{center}
    \begin{tabular}{|c|l|l|l l|} \hline
      番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
      \hline
      02 &        & SIOD   & EQU    & 02H            \\
      03 &        & SIOS   & EQU    & 03H            \\
      00 & 17 00  & START  & LD     & G1,\#0         \\
      02 & 1B 09  &        & LD     & G2,\#9         \\
      04 & C0 03  & LOOP   & IN     & G0,SIOS        \\
      06 & 63 80  &        & AND    & G0,\#80H       \\
      08 & A4 04  &        & JZ     & LOOP           \\
      0A & 11 17  &        & LD     & G0,DATA,G1     \\
      0C & C3 02  &        & OUT    & G0,SIOD        \\
      0E & 37 01  &        & ADD    & G1,\#1         \\
      10 & 4B 01  &        & SUB    & G2,\#1         \\
      12 & A4 16  &        & JZ     & END            \\
      14 & A0 04  &        & JMP    & LOOP           \\
      16 & FF     & END    & HALT   &                \\
      17 &        &        &        &                \\
      17 & 53 48  & DATA   & DC     & "SHIGEMURA"    \\
      19 & 49 47  &        &        &                \\
      1B & 45 4D  &        &        &                \\
      1D & 55 52  &        &        &                \\
      1F & 41     &        &        &                \\
      \hline
    \end{tabular}
  \end{center}}
\end{reidai}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{文字列出力2}{5_8}
  \begin{description}
  \item[問題：] SIOへローマ字で``Tokuyama Kousen''，
    ``Shigemura''のような2行を出力するプログラムを作りなさい．

  \item[考え方：]
    繰り返しにより，1文字ずつSIOへ出力します．
    1行目データと2行目データの間に，復帰コードと改行コードを置きます．
    これらのコードも通常の文字と同じように扱って構いませんので，
    プログラムは2行分を一気に出力するもので構いません．

  \item[プログラム：]
    プログラムにすると次のようになります．
    データの最後の 00H は，データの終わりを示す目印です．
    文字コードが 00H の文字は通常使用しませんので，
    これを文字ではなく終わりの印に使用しました．

    この方法だと，
    出力するデータの長さが変化してもプログラムを変更する必要がありません．

    {\ttfamily\footnotesize\begin{center}
      \begin{tabular}{|c|l|l|l l|} \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        02 &         &  SIOD  &  EQU    & 02H            \\
        03 &         &  SIOS  &  EQU    & 03H            \\
        %00 &         &        &         &                \\
        00 &  17 00  &        &  LD     & G1,\#0         \\
        02 &  19 15  &  L0    &  LD     & G2,DATA,G1     \\
        04 &  5B 00  &        &  CMP    & G2,\#0         \\
        06 &  A4 14  &        &  JZ     & END            \\
        08 &  C0 03  &  L1    &  IN     & G0,SIOS        \\
        0A &  63 80  &        &  AND    & G0,\#80H       \\
        0C &  A4 08  &        &  JZ     & L1             \\
        0E &  CB 02  &        &  OUT    & G2,SIOD        \\
        10 &  37 01  &        &  ADD    & G1,\#1         \\
        12 &  A0 02  &        &  JMP    & L0             \\
        %14 &         &        &         &                \\
        14 &  FF     &  END   &  HALT   &                \\
        15 &         &        &         &                \\
        15 &  54 6F  &  DATA  &  DC     & "Tokuyama      \\
        17 &  6B 75  &        &         &   Kousen"      \\
        19 &  79 61  &        &         &                \\
        1B &  6D 61  &        &         &                \\
        1D &  20 4B  &        &         &                \\
        1F &  6F 75  &        &         &                \\
        21 &  73 65  &        &         &                \\
        23 &  6E     &        &         &                \\
        24 &  0D 0A  &        &  DC     & 0DH,0AH        \\
        26 &  53 68  &        &  DC     & "Shigemura"    \\
        28 &  69 67  &        &         &                \\
        2A &  65 6D  &        &         &                \\
        2C &  75 72  &        &         &                \\
        2E &  61     &        &         &                \\
        2F &  0D 0A  &        &  DC     & 0DH,0AH        \\
        31 &  00     &        &  DC     & 00H            \\
        \hline
      \end{tabular}
    \end{center}}
  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{`A'〜`Z'の文字を表示}{5_9}
  \begin{description}
  \item[問題：] SIOへ`A'〜`Z'の文字を連続して出力するプログラムを作りなさい．

  \item[考え方：]
    `A'〜`Z'の文字コードは連続しています
    （「\figref{chap2:ascii} ASCII文字コード表」参照）．
    最初に`A'の文字コードをレジスタにロードしSIOへ出力します．
    次に，レジスタに1加えて文字コードを増やします．
    増やした結果は`B'の文字コードですので，それを出力します．
    後は同様に`Z'の文字コードまで出力します．

  \item[フローチャート：]
    次の通りです．

    \begin{center}
      \myincludegraphics{Tikz/flowH.pdf}{scale=0.68}
    \end{center}

  \item[プログラム：]
    G0レジスタを文字コードの格納に，
    G1レジスタを「Tビット」のチェックに使います．
    出力可能になったらG0の文字コードをSIOへ出力します．
    出力した後で出力した文字を調べ，`Z'だっら終了します．

    {\ttfamily\footnotesize\begin{center}
      \begin{tabular}{|c|l|l|l l|} \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        02 &       & SIOD  & EQU  & 02H             \\
        03 &       & SIOS  & EQU  & 03H             \\
        %00 &       &       &      &                 \\
        00 & 13 41 &       & LD   & G0,\#'A'        \\
        02 & C4 03 & WAIT  & IN   & G1,SIOS         \\
        04 & 67 80 &       & AND  & G1,\#80H        \\
        06 & A4 02 &       & JZ   & WAIT            \\
        08 & C3 02 &       & OUT  & G0,SIOD         \\
        0A & 53 5A &       & CMP  & G0,\#'Z'        \\
        0C & A4 12 &       & JZ   & OWARI           \\
        0E & 33 01 &       & ADD  & G0,\#1          \\
        10 & A0 02 &       & JMP  & WAIT            \\
        12 & FF    & OWARI & HALT &                 \\
        \hline
      \end{tabular}
    \end{center}}
  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\newpage
\begin{reidai}{echoプログラム}{5_10}
  \begin{description}
  \item[問題：] SIOから入力した文字を
    そのままSIOへ送り返す（こだま）プログラムを作りなさい．

  \item[考え方：]
    STOPボタンが押されるまで終了しないプログラムを作ります．
  \item[フローチャート：]
    次のようなアルゴリズムでできるはずです．

    \begin{center}
      \myincludegraphics{Tikz/flow9.pdf}{scale=0.7}
    \end{center}

  \item[プログラム：]
    G0レジスタを文字コードの格納用に，
    G1レジスタを「Rビット」，「Tビット」のチェック用に使います．
    IN命令でG0へ読み込んだ文字コードを，
    OUT命令で書き戻すことにより文字を送り返します．

    {\ttfamily\footnotesize\begin{center}
      \begin{tabular}{|c|l|l|l l|} \hline
        番地 & 機械語 & ラベル & \multicolumn{2}{|c|}{ニーモニック} \\
        \hline
        02 &       & SIOD  & EQU & 02H            \\
        03 &       & SIOS  & EQU & 03H            \\
        00 &       &       &     &                \\
        00 & C4 03 & START & IN  & G1,SIOS        \\
        02 & 67 40 &       & AND & G1,\#40H       \\
        04 & A4 00 &       & JZ  & START          \\
        06 & C0 02 &       & IN  & G0,SIOD        \\
        08 & C4 03 & WAIT  & IN  & G1,SIOS        \\
        0A & 67 80 &       & AND & G1,\#80H       \\
        0C & A4 08 &       & JZ  & WAIT           \\
        0E & C3 02 &       & OUT & G0,SIOD        \\
        10 & A0 00 &       & JMP & START          \\
        \hline
      \end{tabular}
    \end{center}}
  \end{description}
\end{reidai}

%----------------------------------------------------------------------------
\vfill
\subsubsection{問題}
\begin{enumerate}
\item SIOから1文字入力する度に`\texttt{*}'を送り返すプログラムを作りなさい．
  （パスワード入力を真似する．）
\item
  SIOから1文字入力する度に，
  入力した文字がアルファベット小文字の場合大文字に変換し，
  そうでなければそのままSIOへ出力するプログラムを作りなさい．
\end{enumerate}
\vfill

%----------------------------------------------------------------------------
%\newpage
\section{まとめ}

この章では教育用コンピュータTeCの機械語プログラミングを学びました．
手作業で機械語を作成すること（ハンドアセンブル）を前提にしました．
これらを通して
ノイマン型コンピュータの特徴である以下の三つを体感できたはずです．

\begin{enumerate}
\item データだけでなくプログラムも主記憶に置くこと（ストアードプログラム方式）
\item プログラムの命令はPCで指定されたアドレス順に一つずつ実行されること
  （逐次実行方式）
\item データもプログラも2進数で表現すること（２進法）
\end{enumerate}

そして何より，
1ビットでも間違えるとTeCが正しく動作しないことを痛感したと思います．
これはTeCに限らず現代のノイマン型コンピュータ全てに共通です．
また，C言語やJava言語などの高級言語を用いた場合であっても，
1文字の間違えも許容されないことは共通です．
ノイマン型コンピュータを使用する以上，
ハードウェアもソフトウェアも1ビットも間違ってはならないことを
よく覚えておいて下さい．

ハンドアセンブルによりプログラムを作成するのは効率が悪いので，
アセンブラというプログラムで機械語を自動的に作ることもできます．
TeC用のアセンブラは\url{https://github.com/tctsigemura/Tasm}から入手可能です．
